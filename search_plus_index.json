{"./":{"url":"./","title":"Introduction","keywords":"","body":"易多客的博客 Docker基础知识 Linux基础知识 OAuth2.0基础知识 Python学习计划 Redis基础知识 Vue基础知识 Flask框架基础 MySQL基础知识 PHP进阶知识 Python爬虫基础 TCT:IP基础知识 rsync基础知识 Go基础知识 Nginx基础知识 Python基础知识 React基础知识 Vim基础知识 © 2021 易多客 京ICP备17028238号-1 all right reserved，powered by Gitbookmodify at： 2021-10-21 16:06:24 "},"tech/Docker基础知识.html":{"url":"tech/Docker基础知识.html","title":"Docker基础知识","keywords":"","body":"一、docker三要素 镜像：images 一个集成的应用模板，可以看成是一个只读的模板（包含环境及代码） 镜像可以创建Docker容器，一个镜像可以创建出来多个容器。 类比面向对象中的 类 容器：Container 容器是一个或一组独立运行的应用，一个软件即是容器 可以看成是镜像的实例（有自己所依赖的库和自己的数据；如：mysql/nginx/redis） 可以把容器看作是一个简易版的Linux环境（包括root用户权限、进程空间、用户空间、网络空间等）和运行在其中的应用程序。 类比面向对象中的 实例 和镜像的区别：几乎是一模一样，不同点是容器是可读可写的。 仓库： 是集中存放镜像文件的场所 仓库（Repository）和仓库注册服务（Registry）是有区别的；仓库注册服务器往往存放着多个仓库，每个仓库又包含了多个镜像，每个镜像下有不同的标签（tag） 仓库又分为公开仓库和私有仓库，最大的公开仓库是 Docker Hub 国内最大的公开库有阿里云、网易云等。 Docker： 本身是一个容器运行的载体或称之为管理引擎。 我们把应用程序和配置依赖打包形成一个可交付的运行环境，这个打包好的运行环境就是images，只有通过这个images才能生成Container。images文件可以看作是Container的的模板，一个Container运行一种服务，当我们需要的时候，就可以通过Docker客户端创建一个对应的运行实例(也就是Container) logo的解读： 鲸鱼背着好多个集装箱 蓝色的大海 ----> 宿主机系统 鲸鱼 ---> Docker 集装箱 ---> 容器实例(container) from 镜像(images) 二、常用命令 docker 的信息都存放在宿主机的/var/lib/docker/目录下 1、帮助命令 docker version docker into docker --help docker images --help # 查看当前命令的文档 2、镜像命令 docker images 查看本地的镜像信息 REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest d1165f221234 4 months ago 13.3kB 镜像的仓库源 镜像的标签 镜像ID 镜像创建时间 镜像大小 参数 -a all -q quiet 只显示 镜像ID docker search 查询镜像（去hub.docker.com查询） 参数 -s start 标记星的个数 如： -s 30 为星号大于30的镜像 docker pull 下载镜像，从远程仓库内下载 # docker pull 镜像名称[:TAG] docker rmi 删除镜像。i指image的意思 docker rmi -f mysql nginx docker rmi -f $(docker images -aq) 参数 -f force 强制删除运行中的镜像 3、容器命令 常用 docker run 新建并启动容器（有镜像才能创建容器） # 格式 ：docker run [OPTION] image [COMMAND][TAG] # image为镜像的名称 参数 -d daemon 后台守护进程方式启动运行 -p publish 发布一个容器端口到宿主机端口；宿主机端口:docker容器端口 -P publish all 随机分配端口 -i interactive 交互的 -t tty 一个命令终端 -v volume 卷 --name 定制一个容器别名 -- volumes-from 另一个容器名 把当前容器挂载到另一个容器上 docker ps 列出当前所有正在运行的容器，解读：也就是查看鲸鱼背上有哪几个集装箱在运行 # 格式 ：docker ps [OPTION] [镜像名称] # 镜像名称用于检索 参数 -l latest 列出上一次运行的容器 -a all 列出所有历史运行过的容器 -n number 列出指定个数的历史容器 退出容器 # 基于docker run -it # exit 容器停止且退出 # Ctrl + p + q 容器退出且不停止 docker start 启动容器 # 基于docker ps -n 3 # docker start 容器ID或容器名 docker restart 重新启动容器 # 基于 docker ps docker restart 容器ID或容器名 # 重新启动后可以通过状中的时间来进行查看，时间重新开始计时 docker stop 平滑停止容器。解读：有点类似于电脑关机 # 基于 docker ps docker stop 容器ID或容器名 docker kill 强制停止容器。解读： 有点类似于通过拔掉电源来进行电脑关机 # 基于 docker ps docker kill 容器ID或容器名 docker rm 删除已经停止的容器 # 基于 docker ps docker rm 容器ID或容器名 高级 docker logs 查看容器日志 docker -t -f --tail 容器ID 参数 -t time 时间 -f follow 实时的跟随 docker top 查看容器内运行的进程 # 格式 ：docker top 容器ID docker inspect 查看容器内容细节（检查）。解读：查看千层饼(容器是一层一层的嵌套的)的结构 # 格式 ：docker inspect 容器ID 进入后台正在运行（守护进程）的容器并以命令行交互 # 第一种 docker attach 容器ID # 直接进入容器启动命令的终端，不会启动新的进程 # 第二种 docker exec -t 容器ID 要执行的命令bashShell # -t tty 是在容器外打开新的终端，并且可以启动新的进程 # 也可以不使用-t 从容器内拷贝文件到宿主机上 docker cp # 格式： docker cp 容器ID:容器内路径 目的的主机路径 docker commit 提交容器副本使之成为一个新的镜像 docker commit -m '提交的描述信息' -a '作者' 容器ID 要创建的目标镜像名[:TAG] 4、容器数据卷 卷就是文件或目录，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性。 卷的设计目的就是数据的持久化，完全独立于容器的生命周期，因些Docker不会在删除容器时删除其挂载的数据卷 宿主机和容器的数据可以互相的获取信息通信 容器到容器之间也可以互相获取信息通信 特点 数据卷可在容器之间共享或重用数据 卷中的更改可直接生效 数据卷中有更改不会包含在镜像的更新中 数据卷的生命周期一直持续到没有容器使用它为止 命令 docker volumes 查看当前的卷信息 # 格式： docker volumes [OPTION] 卷名 # docker volumes --help 查看参数 # 卷名可以通过 docker volumes ls 进行查看 1、数据卷绑定一 # 格式一可读可写： docker run -it -v /宿主机的绝对路径目录:/容器的绝对路径目录 镜像名 # 格式二只读(read only)： docker run -it -v /宿主机的绝对路径目录:/容器的绝对路径目录:ro （只能通过宿主机来操作，容器内部是不能操作的） # 格式二可读可写(read write)： docker run -it -v /宿主机的绝对路径目录:/容器的绝对路径目录:rw （宿主机的容器都是可以操作的） # 查看是否挂载成功 docker inspect 容器ID # 容器停止后，在宿主机上进行修改，同一个容器再次启动时会不会信息同步（会的） docker stop 容器ID docker ps -l # 查看上一次运行的容器 docker restart 容器ID # 重新启动容器 docker attatch 容器ID # 进入交互式的命令行 2、数据卷绑定二 使用DockerFile进行添加设置(使用数据卷绑定一方法时，由于宿主机目录是依赖于特定的宿主机的，并不能保证所有的宿主机上都存在这样的目录) docker build -f /mydocker/Dockerfile -t edcoor/contos . # -f 为指定Dockerfile的文件路径 # -t tag 指定构建镜像的名字及版本号 # . 表示当前目录，即Dockerfile所在目录 创建目录mydocker并进入目录，创建文件Dockerfile使用VOLUME指令来给镜像添加一个或多个数据卷 编写Dockerfile文件内容 FROM centos VOLUNS [\"/containerA\", \"/containerB\"] CMD echo \"create file success...\" CMD /bin/bash 进行docker build -f 进行构建 --> 获得一个新的镜像文件 运行新生成的镜像就是定制好的运行环境 docker run 容器内的卷地址已经知道（containerA/containerB），对应宿主机上的目录卷地址是随机生成的（通过docker inspect进行查看） 结论：容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止。 3、Dockerfile 是用来构建docker镜像的配置文件，是由一系列命令和参数构成的脚本。 构建过程解析步骤 # 按file规范编写Dockerfile文件 --> docker build ---> docker run # 使用Dockkerfile定义一个文件之后，docker build会产生一个Docker镜像， 当运行Docker镜像时，会真正开始提供服务（容器是直接提供服务的） 体系结构 或者收保留字指令 FROM基础镜像，当前镜像是基于哪个镜像的 MAINTAINER镜像的维护者的姓名和邮箱地址 RUN 容器构建时需要运行的命令 EXPOSE 当前容器对外暴露的端口 WORKDIR 指定在容器创建后，终端默认登录后所在的目录，第一个落脚点 ENV 用来在构建镜像过程中设置环境变量 ADD 将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包 COPY 类似ADD，拷贝文件或目录到镜像中。将从构建上下文目录中的文件/目录-----复制 ---->新的一层的镜像内的位置 VOLUME 容器数据卷，用于数据保存和持久化工作 CMD 指定一个容器启动时要运行的命令。Dockerfile中可以有多个CMD，但只有最后一个生效，CMD会被 docker run 之后的参数覆盖 ENTRYPOINT 定一个容器启动时要运行的命令。和ADD一样，但不会被docker run 之后的参数覆盖（而是追加） ONBUILD 当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发 查看构建历史 列出镜像的变更历史 docker history 容器ID 4、匿名挂载/具名挂载 匿名挂载(不推荐使用) 卷挂载时不写宿主机的名字，只写容器内对应路径；这时在宿主机上会随机生成一个hash名字对容器内的设置路径形成映射。 # -v 参数后是容器内的路径 docker run -it -P --name nginx01 -v /etc/nginx/ nginx # 宿主机生成的随机目录在 /var/lib/docker/volume/_data/目录内 具名挂载（推荐使用） 卷挂载时不写具体的宿主机的路径，而是使用一个名字进行代替（名字和路径的区别是前面有没有/） # -v 参数后是 宿主机具名:容器内的路径 docker run -it -P --name nginx01 -v nginx-conf:/etc/nginx/ nginx # 宿主机生成的具名目录在 /var/lib/docker/volume/_data/目录内 指定路径挂载（推荐使用） # -v 参数后是 宿主机路径:容器内的路径 docker run -it -P --name nginx01 -v /home/melon/nginx/:/etc/nginx/ nginx 5、联合文件系统 镜像文件是一层一层的，每一个命令会生成一个层（反之每个个层对应一个操作）。 Docker镜像是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部，这一层我们就称这容器层，容器之下的都叫镜像层。 © 2021 易多客 京ICP备17028238号-1 all right reserved，powered by Gitbookmodify at： 2021-07-24 08:14:18 "},"tech/Linux基础知识.html":{"url":"tech/Linux基础知识.html","title":"Linux基础知识","keywords":"","body":" © 2021 易多客 京ICP备17028238号-1 all right reserved，powered by Gitbookmodify at： 2021-04-09 06:53:26 "},"tech/OAuth2.0基础知识.html":{"url":"tech/OAuth2.0基础知识.html","title":"OAuth2.0基础知识","keywords":"","body":"四种授权许可类型 场景一： 用户通过微信方式登录第一方应用，这其中有三个角色； 用户（资源拥有者） 第三方软件APP（第三方应用） 第三方软件服务端（第三方应用服务） 资源授权服务器（受保护的资源授权方） 资源服务器（受保护资源提供方） 授权方式： 授权码许可类型：（authorization-code 授权码） 多应用于三方（用户、百度、微信）各自都不相互信任时的场景；适用于一切有服务端的Web应用； # 第一步：第三方应用网站提供一个链接 -----> 当用户点击后会跳转到资源授权服务器提供的页面（展示出用户是否同意授权） # 第二步：用用户同意授权后跳转到第三方应用网站指定的重定向地址，同时会带上授权码 ------> 第三方应用网站获得授权码 # 第三步：第三方应用服务端通过授权码向资源授权服务器发起请求索取token -----> 资源授权服务器响应返回token到第三方应用服务端指定的地址 # 第四步：第三方应用服务端通过令牌向资源服务器获取数据 隐式许可类型：（implicit 隐藏式） 第三方软件运行在浏览器中的应用；一般应用在没有服务端的应用中，把token直接发给客户端（纯前端没有后端） 这种把令牌直接放在客户端的方式很不安全，一般用在对安全性要求不高的场景中，并且令牌的有效期非常短。 # 第一步：第三方应用网站提供一个链接 -----> 当用户点击后会跳转到资源授权服务器提供的页面（展示出用户是否同意授权） # 第二步：用用户同意授权后跳转到第三方应用网站指定的重定向地址，同时会带上token ------> 第三方应用网站获得token # 第三步：第三方应用服务端通过令牌向资源服务器获取数据 资源拥有者凭据许可类型：（password 密码式） 适用于信任度极高的软件应用；用户把账号密码直接告诉第三方应用，第三方应用就使用账号密码申请token; # 第一步：用户--> 在第三方应用输入账号密码(资源方的) ---> 到第三方服务端拿账号密码向资源授权服务器索取token # 第二步：资源授权服务器返回token给第三方服务器 ----> 第三方服务器拿token去资源服务器获取数据 客户端凭据许可类型：（client-credentiails 客户端凭证） 适用于应用程序直接访问资源的场景，一般适用于没有前端的命令行应用（在命令行下请求令牌） 这种方式给出的令牌是针对第三方应用的，而不是针对用户的，即存在多个用户共享同一个令牌。 # 第一步：第三方应用在命令行下向资源授权服务器发起请求 -----> 资源授权服务器验证通过后响应返回token # 第二步：第三方应用服务端通过令牌向资源服务器获取数据 令牌的使用方式： 第三方应用服务端通过令牌向资源服务器开放的API获取数据，具体做法是在请求头信息中添加一个Authorization字段 curl -H 'Authorization: bearer ACCESS_TOKEN' https://api.other.com # 其中 ACCESS_TOKNE就是令牌 更新令牌： 令牌到期后如果让用户再申请一个令牌体验非常不好，OAuth2.0允许用户自动更新令牌。资源授权服务器在颁发令牌时一次性颁发了两个令牌，一个是令牌，另一个是刷新令牌的令牌。 # 第一步：第三方应用在命令行下向资源授权服务器发起请求刷新令牌 -----> 资源授权服务器验证通过后响应返回新的token # 第二步：第三方应用服务端通过刷新后的令牌向资源服务器获取数据 © 2021 易多客 京ICP备17028238号-1 all right reserved，powered by Gitbookmodify at： 2021-08-16 07:12:00 "},"tech/Python学习计划.html":{"url":"tech/Python学习计划.html","title":"Python学习计划","keywords":"","body":"第一周（09.14--09.19） 主要： 1、字符串 2、列表 3、元组 4、字典 5、集合 次要 1、什么时解释器 2、注释的写法 3、运算符有哪些 4、了解数字类型（number） 第二周（09.21-09.26） 1、条件控制 2、循环语句 3、迭代器与生成器 4、函数 5、数据结构 6、模块 7、输入和输出 第三周（09.28-10.10） 1、文件操作 2、OS模块 3、错误和异常 第四周（10.12-10.17） 1、面向对象 2、命名空间/作用域 3、标准库 第五周 巩固、回顾（10.19-10.23） 项目-问卷调查项目(10.24) 第六周 巩固、回顾（10.26-10.30） 项目-问卷调查项目（10.31） © 2021 易多客 京ICP备17028238号-1 all right reserved，powered by Gitbookmodify at： 2020-10-13 07:40:14 "},"tech/Redis基础知识.html":{"url":"tech/Redis基础知识.html","title":"Redis基础知识","keywords":"","body":"一、为什么要使用NoSQL 1、MySQL的演进史 a、单机时代架构 APP应用 —> 数据访问层DAL —> MySQL 90年代一个网站的访问量不会太大， 一个数据库就搞定了，那个时候使用静态网页Html服务器根本没有太太的压力。 当遇到下面的情形时，会出现什么情况？ 数据量如果太大，一台机器已经放不下了？ 数据库有索引（index）一台机器内存已经放不下了？ 访问量（读写混合），一台服务器扛不了了？ 出现上面的情况时就需要进行晋级~ b、Memecach + MySQL + 垂直拆分 ​ | ——> MySQL从库（与主库同步） APP应用 —> 数据访问层DAL —> Memecach —> MySQL主库 ​ |——-> MySQL从库（与主库同步） 80%的请求都是在读取数据，每次都要从库内查询比较麻烦，为了减轻库有压力使用缓存来保证效率~ 缓存发展历程： 优化数据库索引 ——> 文件缓存（IO） ——-> memecache缓存（当时最热门的技术！） c、分库分表 + 水平拆分 + MySQL集群 ​ | ——> MySQL从库（与主库同步） ​ （集群1）|———-| ——> Memecach —> MySQL主库 ​ | |——-> MySQL从库（与主库同步） ​ | ​ | | ——> MySQL从库（与主库同步） APP应用 —> 数据访问层DAL —> 缓存 ——> |———-|—> MySQL主库 ​ | |——-> MySQL从库（与主库同步） ​ | ​ | | ——> MySQL从库（与主库同步） ​ （集群2）| ———|—-—> MySQL主库 ​ |——-> MySQL从库（与主库同步） d、最近年代（大数据） 2010-至今，当今时代会产生数量庞大的数据，如：用户位置、操作记录、热榜。 MySQL对于大量的数据存储已经力不从心了~ 于是乎就出现了NoSQL，这就是为什么要引入NoSQL的原因。 NoSQL = not only SQL (不仅仅是SQL) 泛指非关系型数据库。 随着web2.0互联网的诞生，传统的关系型数据库不能满足web2.0时代。尤其是在大数据时代~暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的，而且是我们当下必要掌握的一个技术! 2、NoSQL 特点： 方便扩展（数据之间没有关系，很好扩展） 大数据量高性能（一秒写8万次，读取11万次） 数据结构是多样性型的（不需要设计数据库，随取随用） SQL VS NoSQl # 传统的SQL 1. 结构化组织 2. SQL语句 3. 数据和关系都存在于表内 col row 4. 操作数据定义语句 5. 严格的一致性 6. 基础的事务 # NoSQL 1. 不仅仅是数据 2. 没有固定的查询语句 3. 键值对存储，列存储、文档存储、图形数据库 4. 最终一致性 5. 高性能、高可用、高可扩（三高） 应用到实际解决的问题： # 3V: 主要描述的问题 海量Velume 多样Variety 实时Velocity # 3高：主要对程序的要求 高并发 高可扩 高性能 NoSQL配合其它数据库的使用案例： # 业务模型的各个字段公布在不同的数据源中 商品信息： 基本信息 ------> mysql spu属性(SPU = Standard Product Unit 标准化产品单元) ------> Document DB 图片 ------> OSS 相关关键字 ------> Search Engine # 1、商品的基本信息 名称、价格、商家信息。使用关系型数据库就可以解决 # 2、商品的描述、评论（文字较多） 文档型数据库，MongoDB # 3、商品图片 分布式的文件系统，如阿里云的OSS、淘宝的TFS # 4、商品的关键字（搜索） 搜索引擎 elasticsearch # 5、商品热门的波段信息 内存数据库，Redis/Memecache 架构师最简单的标准： 没有什么时不能加一层来解决的，如果有就再加一层~ # 架构示例 应用网站 | | 统一数据服务平台（UDSL） | | 热点缓存平台（UDSL的二级缓存） - 热点规则、KEY规则、过期规则 - 热点匹配、Key生成、缓存读写 - 事件过期、自动过期 | | 热点数据库 二、NoSQL的四大分类 KV键值对： Redis、Memecache 文档型数据库（bson和json一样） MongeDB: 是一个基于分布式文件存储系统，主要用来处理大量的文档 其是一个介于关系型数据库和非关系型数据库之间的产品，MongoDB是非关系型数据库中最像关系型数据库的！ 列存储数据库 HBase、分布式文件系统 图关系数据库 Neo4j、InfoGrid 它不是存储图形的，存储是的关系，比如：朋友圈的社交网络，广告推荐~ 三、Redis入门 1、概述 Redis是什么？Redis（==Re==mote ==Di==ctionary ==S==erver )，即远程字典服务。 2、安装 # 第一步 # 下载安装包到linux上[官方文档](http://redis.cn/) # 第二步 # 移动安装包到`/opt`下并解压Redis安装包，进入解压后的安装包执行安装命令 install gcc-c++ make make install # 第三步 # 默认的安装目录为`/usr/local/bin` # 第四步 # 将解压目录内的配置文件`redis.conf`复制到自定义的配置目录内，并打开配置文件修改如下： deamonize yes # 第五步 # 使用自定义的配置文件启动redis redis-server /my/path/to/redis/redis.conf # 第六步 # 使用redis-cli进行连接测试 redis-cli ping # 第七步 # 关闭redis-server # 在第六步的基础上执行命令 shutdown exit # 第八步 # 查看redis-server是否存在 ps -ef | grep redis 3、测试性能工具 redis-benchmark 是一个压力测试工具 1 -h 指定服务器主机名 127.0.0.1 2 -p 指定服务器端口 6379 3 -s 指定服务器 socket 4 -c 指定并发连接数 50 5 -n 指定请求数 10000 6 -d 以字节的形式指定 SET/GET 值的数据大小 3 7 -k 1=keep alive 0=reconnect 1 redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000 -t set,get 4、基础知识 默认有16个数据库，在配置文件内database 16。默认使用的是第0个数据库 端口号为6379，按键手机的MERZ(外国的明星)对应的数字 # 切换数据库 select 2 # 当前数据库中数据的大小 DBSIZE # 清除当前所在数据库中的所有数据 flushdb # 清除所有数据库中的数据 flushall # 查看当前库中有所有Key keys * Redis是单线程的，为什么单线程还这么的快？ 基于内存操作，CPU不是其性能瓶颈，其性能瓶颈是内存大小和网络带宽。官方提供的数据为100000+ QPS 误区1：高性能的服务一定是多线程？ 误区2：多线程（CPU上下文会切换）一定比单线程效率高？ 核心：Redis是将数据全部放在内存中，使用单线程去操作效率是最高的，多线程会有上下文的切换耗时操作！ 对于内存来说没有上下文切换效率就是最高的，多次的读写都是在一个CPU上对于内存来说就是最佳的方案。 5、五大数据类型 Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。 Redis-Key # 查看所有的key keys * # 移除key move keyName # 为key设置过期时间 expire keyName second # 查看key的剩余时间 ttl keyName # 判断当前key是否存在 exists keyName # 查看当前key的类型 type keyName String（字符串） 应用场景 计数器 统计多单元的数量 (uid:3353:watch) 对象缓存存储 # 设置key的值 set name 'jack' # 获取key的值 get name # 判断Key是否存在 exists name # 向key对应的值字符串后追加内容 append name otherStr # 获取key对应值的长度 strlen name --------------------------- # 自增一个数字 incr num # 自增两个数字（步长为2） incrby num 2 # 自减一个数字 decr num # 自减三个数字（步长为3） decrby num 3 ------------字符串范围--------------- # 截取0-3个字符【前闭后闭】 getrange str1 0 3 # 获取所有的字符串内容 getrange str1 0 -1 ------------字符串替换--------------- # setrange key offset value 替换指定位置的字符串 set key2 aaaaa setrange key2 1 xx get key2 ----> axxaa --------------------------- # setex (set with expire) 设置过期时间 setex key second value set key3 10 myexpirestr # setnx (set if not exist) 不存在再设置 在分布式锁中会常常使用 setnx key value setnx key4 strkey4 setnx key4 strkey3 -----------批量操作---------------- # 批量设置值 mset key value key1 value1 key2 value2 ..... mset k1 v1 k2 v2 keys * # 批量获取值 mget key key1 key2.... mget k1 k2 # 原子操作批量 (要么一块成功~ 要么一块失败~) msetnx key value key1 value1 key2 value2 ..... msetnx k1 v1 k5 v5 # k1 已经存在所以都会失败 -----------组合操作---------------- # 先获取再设置，若值不存在，则返回nil，如果存在则返回原来的值再设置新的值 getset key value getset name jack List（列表） 在Redis中我们可以把List玩成 栈、队列、阻塞队列！ 命令不区分大小写 实际是一个链表，before NODE after ， left， right 都可以插入 如果key不存在，创建新的链表，存在则新增内容 如果移除了链表内有所有数据，空链表也代表不存在！ 在两边插入或改动值效率最高！操作中间元素效率相对会低一点~ 应用场景 消息队列（Lpush Rpop） 栈（Lpush Lpop） # 判断key存在与否，返回0和非0 # 格式： exists key exists k3 # 将一下值或多个插入到列表的内（左侧） # 格式： LPUSH key value [value1....] lpush k1 v1 v2 # 获取列表内的值，也可以通过区间获取列表内的值 # 格式： LRANGE key start stop lrange k1 0 -1 lrange k1 0 1 # 将一下值或多个插入到列表的内（右侧） # 格式： RPUSH key value [value ...] rpush k1 v3 # 通过下标来设置值（前提是列表key已经存在且下标也存在，否则会报错） # 格式： lset key index value lset k1 0 other lset k1 100 count # 在列表指定的值前、后插入一个值 # 格式：linsert key BEFORE|AFTER pivot value linset k1 before v2 myInsertValue linset k1 after v2 youInsertValue -----------移除操作---------------- # 从左侧移除列表内一个元素，返回移除后的元素值 # 格式： lpop key lpop k1 # 从右侧移除列表内一个元素，返回移除后的元素值 # 格式： rpop key rpop k1 # 通过值来删除，若有多个值相同可以指定删除的值个数, 若实际个数据小于删除个数则以实际个数据为准 # 格式： lrem key count value lrem k1 1 v1 lrem k1 2 v1 # 截取通过下标，前半后闭；会改变原list的值，原list只剩下截的内容；返回值为OK # ltrim key start stop ltrim k1 1 2 -----------下标取值---------------- # 通过下标取值，若没有值则返回nil, 可以应用到阻塞队列场景中 # 格式： lindex key index lindex k1 0 lindex k1 1 # 返回列表的长度 # 格式： llen key llen k1 -----------组合操作---------------- # 移动列表的第一个元素到新的另一个列表内；移动后两个列表内的值相加就是原始列表 # 格式： rpoplpush source destination rpoplpush k1 k2 Set（集合） 特点：无序的集合，没有重复值 应用场景： 粉丝关注、共同关注 做了A，又做了B，同时做了A和B的用户 # 向集合内添加元素，添加重复的值会返回零，成功则返回非零 # 格式：sadd key member [member ...] sadd s1 1 # 获取集合内的所有元素 # 格式：smembers key smembers s1 # 判断value是否是集合内有元素,返回非零和零 # 格式：sismember key member sismember s1 2 sismember s1 1 --------------------------- # 获取集合内元素的个数 # 格式：scard key scard s1 --------------删除操作------------- # 移除集合中的指定元素 # 格式： srem key member [member ...] srem s1 1 # 随机删除集合中的指定个数的元素, 返回删除的元素 # 格式： spop key [count] spop s1 2 --------------随机取值操作------------- # 随机抽选出集合中的指定个数的元素 # 格式：srandmember key [count] srandmember s1 2 --------------复合操作------------- # 把s集合中的member元素移动到d集合内 # 格式：smove source destination member smove s1 s2 'jack' # 应用场景，粉丝的关注，共同关注、全部关注 # 集合的差集,以第一个key为参照 # 格式： sdiff key [key ...] sdiff s1 s2 # 集合的交集 # 格式： sinter key [key ...] sinter s1 s2 # 集合的并集 # 格式： sdiff key [key ...] sunion s1 s2 Hash（散列） Map集合 ——-> key：Map 相当于值是一个map 应用场景： 适用于对象的存储 适用于标记每个用户的信息 # 设置一个map # 格式：hset key filed value hset h1 name jack # 获取一个map值 # 格式： hget key filed hget h1 name # 对一个键设置多个值 # 格式： hmset key filed1 value filed2 value [filed value ...] hmset h2 name rose age 12 # 获取一个键设置多个值 # 格式： hmget key filed1 filed2 [filed ...] hmget h2 name age # 获取所有的key, 返回key:value # 格式：hgetall key hgetall h1 # 获取长度 # 格式： hlen key hlen h1 # 判断是否存在,若存在则不再进行设置，返回零和非零 # 格式：hsetnx key field value hsetnx h2 name melon --------------删除操作------------- # 删除哈希指定的key的filed，对应的value也就消失了，成功则返回非零 # 格式： hdel key field [field ...] hdel h1 name age --------------------------- # 判断hash的key中指定的字段是否存在, 返回零或非零 # 格式：hexists key field hexists h1 name hexists h1 name1 # 获取key的所有字段 # 格式： hkeys key hkeys h1 # 获取key的所有字段对应的值 # 格式： hvals key hvals h1 --------------自增自减------------- # 自增 # 格式：hincrby key field increament hincrby h2 index 1 # 自减 # 格式：hdecrby key field decreament hdecrby h2 index 2 Zset（有序集合） 在set的基础上添加了一个值（用来进行排序） 应用场景： 排行榜 成绩表 加权判断 # 向集合内添加一个元素 # 格式：zadd key score member [score member ...] zadd z1 2 jack 3 rose # 获取集合内值升序(前闭后闭) # 格式：zrange key start stop zrange z1 0 -1 zrange z1 0 1 # 获取集合内值降序(前闭后闭) # 格式：zrevrange key start stop zrevrange z1 0 -1 zrevrange z1 0 1 # 获取排序好的集合 # 格式： zrangebyscore key min max [withscores] [limit offset count] # 格式： zrevrangebyscore key max min [withscores] [limit offset count] zrangebyscore z1 -inf +inf withscores zrangebyscore z1 -inf +inf withscores limit 0 1 ZREVRANGEBYSCORE z1 +inf -inf withscores Limit 0 1 # 查看集合的长度 # 格式：zcard key zcard z1 # 获取序号在指定范围区间元素的个数 # 格式：zcount key min max zcount z1 2 3 # 变更序号值 # 格式：zincrby key increament mumber zincrby z1 2 name --------------移除操作------------- # 从集合内移除指定的元素 # 格式：zrem key member [member ...] zadd z2 2 name 3 age zrem z2 name age 6、三种特殊类型 geospatial（地理位置） Redis在3.2版本推出了geo，这个功能可以推算地理位置的信息，两地之间的距离，方圆几里的人。 # 添加位置信息 # 格式：geoadd key longitude latitude member [longitude latitude member ...] geoadd china:city 116.40 39.90 beijing geoadd china:city 121.47 31.23 shanghai 120.16 30.24 hangzhou # 从key里返回所有给定位置元素的位置（longitude latitude） # 格式：geopos key member [member ...] geopos china:city beijing shanghai # 返回两个位置之间的距离 # 格式：geodist key member1 member2 [unit] 指定单位的参数 unit 必须是以下单位的其中一个(默认是m)： m 表示单位为米。 km 表示单位为千米。 mi 表示单位为英里。 ft 表示单位为英尺。 geodist key beijing shanghai # 以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。（我附近的人，通过半径来查询） # 格式：GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [COUNT count] GEORADIUS china:city 116 38 1000 km GEORADIUS china:city 116 38 800 km withcoord GEORADIUS china:city 116 38 1000 km withcoord withdist count 2 # 中心点是由给定的位置元素决定的， 而不是像 GEORADIUS 那样， 使用输入的经度和纬度来决定中心点 # 格式：GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] GEORADIUSBYMEMBER china:city shanghai 300 km withcoord withdist GEORADIUSBYMEMBER china:city shanghai 300 km withcoord withdist count 1 # geo 底层原理是有序集合zset, 我们可以使用zset来操作geo ZRANGE china:city 0 -1 withscores zrem china:city beijing hyperloglog（超级日志） Redis在2.8.9就集成了Hyperloglog数据结构，其是基数统计的算法. 优点： 占用内存是固定的，2^26个元素的个数，只需要12kB的内存！如果要从内存角度来比较的话Hyperloglog是首选！ 基数不大，数据量不大就用不上，会有点大材小用浪费空间 有局限性，就是只能统计基数数量，而没办法去知道具体的内容是什么 和bitmap相比，属于两种特定统计情况，简单来说，HyperLogLog 去重比 bitmap 方便很多 一般可以bitmap和hyperloglog配合使用，bitmap标识哪些用户活跃，hyperloglog计数 应用场景：网页的UV（一个人访问一个网站多次，但是还是算作一个人） 传统的方式会使用set来保存用户UID,通过总数据量来计数，我们的目的是用为计数而不是保存用户UID。 统计注册 IP 数 统计每日访问 IP 数 统计页面实时 UV 数 统计在线用户数 统计用户每天搜索不同词条的个数 缺点： 如果允许容错，那么一定使用Hyperloglog # 创建一组元素 # 格式：PFADD key element [element ...] PFADD p1 a b c d e f g # 查看从个组内的元素个数（个数和） # 格式：PFCOUNT key [key ...] PFCOUNT p1 # 合并多个组的数据并去重 key1 + key2 + ... ==> keyN # 格式：PFMERGE destkey sourcekey [sourcekey ...] PFMERGE key3 key1 key2 PFCOUNT key3 bitmaps（位存储） 应用场景：统计用户登录、未登录；打卡、未打卡；只有两个状态的都可以使用Bitmaps 特点：位图数据结构。都是操作二进制位来进行记录。只有0和1两个状态！ 365天 = 365bit 1字节=8bit 约46个字节左右~ 案例： 很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做setbit操作时将用户id减去这个指定数字。 在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。 # 示例：记录打卡数 offset为某一天，value为0或1表示打卡与否 # 添加标记 # 格式：setbit key offset value SETBIT bit 1 0 SETBIT bit 2 1 SETBIT bit 3 1 SETBIT bit 4 0 SETBIT unique:users:2016-04-05 8 0 # 记录用户1000008在这一天打卡 # 查看某一天是否打卡 # 格式：getbit key offset GETBIT bit1 1 GETBIT unique:users:2016-04-05 8 # 用户1000008在这一天是否打卡 # 统计操作 [start]和[end]代表起始和结束字节数，注意不是偏移量 # 格式：bitcount key [start end] bitcount bit1 # 复合操作 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中。分别使用的是位运算 # 格式：bitop destkey key [key ...] bitop and resultKey bit1 bit2 但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如表3-5所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0。 庞大的用户量 数据类型 每个用户id占用空间 需要存储的用户量 全部内存量 集合类型 64位 50,000,000 64 * 50,000,000 = 400M Bitmaps 1位 100,000,000 1 * 100,000,000 = 12.5M 较少的用户量 数据类型 每个用户id占用空间 需要存储的用户量 全部内存量 集合类型 64位 100,000 64 * 100,000 = 800KB Bitmaps 1位 100,000,000 1 * 100,000,000 = 12.5M 四、Redis高级 1、事务 事务的本质：一组命令的集合。一个事务中的所有命令都会被序列化，在事务执行过程中会按照顺序执行！ 事务没有隔离级别的概念 单条命令保持原子性，但事务不保证原子性 一次性、顺序的、排他的执行一系列的命令 # 步骤 - 开启事务（Multi） - 命令入队（...） - 执行事务（Exec） # 可以看作是一个队列 ----- # 命令一个一个的进入队列 命令1 命令2 命令3 ... # 只有执行exec命令的时候才真正的执行上面的命令 exec ----- 常用命令 multi 开启事务 exec 执行事务 discard 取消事务(取消事务后命令就不会被执行) watch 监控 事务特点： 编译型异常（代码有问题，命令有错误）事务中的所有命令都不会被执行！ 运行型异常（逻辑有问题，如：1/0）如果事务执行的过程中存在语法性问题，那么在执行命令的时候其它命令可以正常执行。错误的命令抛出异常。 # 示例 multi # 开启事务 set k1 v1 set k2 v2 get v1 set k3 v3 exec # 执行事务 multi # 开启事务 set k4 v4 discard # 放弃事务 ###### 命令有错误 multi # 开启事务 set k4 v4 getset k5 # 此处命令有问题 exec # 事务报错，所有命令执行不成功 ###### 运行时有错误 multi # 开启事务 set k4 \"string\" incr k4 # 此处不能对字符串累加 exec # 其它命令执行成功，只有incr命令执行不成功 watch （监控） 对事务添加监控 悲观锁：很悲观，认为什么时候都有可能出问题，无论做什么都会加锁！ 乐观锁：很乐观，认为什么时候都不会出问题，所以不会上锁！只有在更新数据的时候才会添加锁判断一下，在此期间内是否有人修改过数据。 通过获取version —-> 更新的时候比较version # 使用乐观锁的场景：当一个线程在执行期间另一个线程恰好修改了数据时 set money 100 set out 0 watch money multi # 添加事务 decr money 10 # 此时另一个线程修改了 incr money 22 incr out 10 exec # 这里会执行失败 返回nil unwatch # 解锁 # 这各失败后，解锁再执行一遍即可 2、Redis配置文件 配置文件名为 redis.conf （行家一出手，便知有没有） INCLUDES 可以添加多个配置文件 NETWORK bind 127.0.0.1 配置IP地址 port 6379 设置商品号 GENERAL 能用配置 deamonize yes 是否以后台守护进程的方式运行 默认为no 要修改为yes pidfile /var/run/redis_6379.pid 如果以后台守护进程方式运行，就要设置进程文件 loglevel notice 日志级别 logfile ‘’ 日志的文件名 databases 16 数据库数量 always-show-logo yes 是否显示LOGO SNAPSHOTTING 快照 # 持久化，在规定的时候内，执行了多少次操作后就会持久化到文件 .rdb .aof # redis是内存数据库，若没有持久化，那么断电后数据就会丢失！ save 900 1 # 900秒内若至少有1个key修改则进行持久化 save 300 10 save 60 10000 stop-writes-on-bgsave-error yes # redis出错后是否还要继续工作 rdbcompression yes # 是否压缩rdb文件，需要消耗cpu资源 rdbchecksum yes # 保存rdb的时候进行错误校验 dbfilename dump.rdb # rdb文件的文件名 dir /var/lib/redis # rdb文件的保存目录 REPLICATION 主从复制 SECURITY 安全 equirepass myPassword #设置密码 # 也可以使用命令设置密码（即时性的，重启redis后密码失效） config set equirepass 123456 config get equirepass LIMITS 限制 maxclients 10000 # 最大链接数 maxmemory 20GB # 最大的内存容量 maxmemory-policy noeviction # 内存达到上限后的处理策略 # maxmemory-policy 六种方式 1、volatile-lru：只对设置了过期时间的key进行LRU（默认值） 2、allkeys-lru ： 删除lru算法的key 3、volatile-random：随机删除即将过期key 4、allkeys-random：随机删除 5、volatile-ttl ： 删除即将过期的 6、noeviction ： 永不过期，返回错误 APPEND ONLY MODE 追回模式 默认使用的是rdb方式持久化，在大部分情况下rdb方式完全是够用的！ # aof模式 默认是不开启的 appendonly no appendfilename \"appendonly.aof\" # aof持久化的文件名 appendfsync everysec # 每秒都同步一下命令，可能会丢失一秒的数据 3、Redis持久化 Redis是内存数据库，若不把数据保存到磁盘内，进程退出或断电等情况时就会数据丢失，所以才会有Redis持久化功能！ rdb (Redis Database) 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。 Redis会单独创建一个(fork)子进程来进行持久化，公先将数据写入一个临时文件中，持久化过程都结束后再将这个临时文件替换上次持久化的文件成为正式的rdb文件。整个过程中，主进程是不进行任何IO操作，这就确保了极高的性能。如果要进行大规模的数据恢复，且对数据的完整性不是非常敏感，那么RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次的数据可能会丢失，默认情况下使用的是RDB模式，一般不需要进行修改。 生成RDB文件的几种方式： save规则满足的条件下会自动触发rdb文件生成 执行flushall清除所有数据时会自动触发rdb文件生成 退出Redis时也会产生rdb文件 备份就会自动产生dump.rdb文件 恢复RDB文件： 查看dump.rdb文件存放的位置 config get dbfilename # 查看文件名 config get dir # /usr/local/bin 如果在这个目录下存放上面查出的文件名(一般为dump.rdb)，redis启动的时候会自动的检查dump.rdb并恢复其中的数据！ 把dump.rdb文件放到上面查询出的目录下就即可 优点： 适合大规模的数据恢复 对数据的完整性要求不高 缺点： 需要一定的时间间隔进行进程操作，如果redis宕机，最后一次没有持久化的信息就丢失了 fork进程的时候会占用一定的内存空间！ 提醒： 几乎默认的配置就够使用了，但是还是需要学习如何使用配置！ AOF（Append Only File） © 2021 易多客 京ICP备17028238号-1 all right reserved，powered by Gitbookmodify at： 2021-09-13 07:31:52 "},"tech/Vue基础知识.html":{"url":"tech/Vue基础知识.html","title":"Vue基础知识","keywords":"","body":"一、ES6部分 1、let和var和const var 针对if、for 是没有块级作用域，var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined let所声明的变量只在let命令所在的代码块内有效(包含if、for) const是声明常量时使用的关键字 函数有自己的作用域，var let都能够在函数内限定其作用域只在函数内部使用 let声明变量存在暂时性死区（即变量会绑定某个区域，不受外部影响） let在变量没有声明时使用，使用会报错；var会返回undefind const 修饰的的标识符不可再次赋值，以保证数据的安全性 const的含意是指向的对象不能进行修改，但是可以改变对象内部的属性 var btns = document.getElementsByTagName('button'); // for (var i=0; i 2、对象增强写法 属性 // ES6之前 let name = 'jack'; let age = 18; let obj1 = {name: name, age: age}; // ES6之后 let obj2 = {name, age}; // 和上面obj1结果是一样的 方法 // ES6之前 let obj1 = { getName: function(){ console.log('my name is jack'); } } // ES6之后 let obj2 = { getName() { console.log('my name is rose'); // 和上面的结果是一样的 } } 解构 有对象、数组解构 // 对象的解构 const obj = {name: 'jack', age: 12} const {name, age} = obj console.log(name, age) // 'jack' 12 // 数组的解构 const arr = [12,23] const {arr1, arr2} = arr console.log(arr1, arr2) // 12 13 二、Vue基础 1、常用指令 v-on 绑定事件监听，缩写是@，参数为event 参数传递 //点我 点我 // 1、写方法时省略了小括号，但是方法本身是需要一个参数的，这个时候，Vue会默认将浏览器产生的event事件对象作为参数传递到方法内 点我 // 2、定义方法时，若同时需要event对象和其它参数时，使用$event 修饰符 在拿到event时可以进行一些事件处理，Vue也提供了一些修饰符来帮助我们方便处理一些事件 .stop -- 调用event.stopPropagation() .prevent -- 调用event.preventDefault() .enter -- 特定键触发 .once -- 只触发一次 // 停止冒泡 点我 // 阻止默认行为,如表单提交 点我 // 关联修饰符 点我 // 键别名 点我 点我 // 只触发一次 点我 v-if-ifelse-else v-show v-for v-model 对表单元素进行双向数据绑定。 原理：v-model 双向绑定实际上就是通过子组件中的$emit方法派发 input 事件，父组件监听 input 事件中传递的 value 值，并存储在父组件 data 中；然后父组件再通过 prop 的形式传递给子组件 value 值，再子组件中绑定 input 的 value 属性即可。 也可理解为分两步进行操作，第一步使用v-bind为表单元素绑定属性，第二步使用v-on监听表单元素的input的事件，并在事件内重新设置值，从而实现双向数据绑定 // 第一种方式 // 第二种方式 // 第三种方式 const app = Vue({ data: { message: 'yes', } methods: { valueChange(event) { this.message = event.target.value; } } }) 修饰符： lazy： v-model.lazy 可以让数据在失去焦点呀回车时才会更新 number： v-model.number 默认情况下输入的内容都会认为是字符串；number可以让在输入框中输入的内容自动的转换为数字类型 trim： v-model.trim 如果在输入时首尾都有很多的空格，trim修饰符可以过滤左右两边的空格。 2、常用操作 a、splice Vue中对数组的操作中哪些方法是响应式的呢？ 以下方法Vue内部是已经添加的监听的，所以可以使用并能生效 arr.push(...items) 在数组最后添加一个或多个元素 arr.pop(...items) 删除数组中最后一个元素 arr.shift() 删除数组中第一个元素 arr.unshift(...items) 在数组最前面添加一个或多个元素 arr.splice(start, deleteCount, ...items) 删除元素/插入元素/替换元素 var arr = ['a', 'b', 'c', 'd', 'e', 'f']; // 删除元素: 第一个位置为开始位置，第二个参数传入要删除的元素个数（若没有传递，则删除后面所有的元素） arr.splice(1, 3) // ['a', 'e', 'f'] // 插入元素：第一个位置为开始位置，第二个参数传入0表示不进行删除，后面跟上要插入的元素 arr.splice(1, 0, 'g', 'i', 'h') // ['a', 'g', 'i', 'h', 'b', 'c', 'd', 'e', 'f'] // 替换元素：第一个位置为开始位置，第二个参数为要替换的元素个数，后面是要替换的元素 arr.aplice(2, 2, 'm', 'n') // ['a', 'b', 'm', 'n', 'c', 'd', 'e', 'f'] // 注：在Vue中使用索引对数组进行变更值时，是不能生效的 arr[0] = 'aaaa'; // 在页面上是不生效的 b、filter/map/reduce Vue中高阶函数的使用： filter： callback(currentValue,index,arr) 其参数为回调函数，回调函数必须要返回一个布尔值；返回值为一个新的数组。 const arr = [10, 20, 40, 80, 100, 120]; // 过滤小于100的数 let newArr = arr.filter(function(n){return n n map： callback(currentValue, index,arr)，内部是映射，返回对原数据处理后的数据，法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。方法按照原始数组元素顺序依次处理元素。 const arr = [10, 20, 40, 80, 100, 120]; // 对每一个元素进行乘2 let newArr = arr.map(function(n) {return n*2}); // [20, 40, 80, 160, 200, 240] let newArr = arr.map(n => n*2) // [20, 40, 80, 160, 200, 240] reduce：callback(total,currentValue, index,arr)，要传递两个值，total为计算结束后的返回值；currentValue为当前元素；返回值为计算结果。 const arr = [10, 20, 40, 80, 100, 120]; // 对一个数组进行累加 let count = arr.reduce(function(total, n){return total + n}) // 370 let count = arr.reduce((total, n) => total + n); // 370 3、Vue组件 组件是可复用的 Vue 实例，组件分为全局组件和局部组件；组件内的data必须是一个函数 定义组件 // 原始定义 const component1 = Vue.extend({ template: `你好`, // components: {other: otherComponent,} // 这里可以定义子组件 }) // 简化定义，又称组件的语法糖写法 Vue.components({ component1: { template: ``, // components: {other: otherComponent,} // 这里可以定义子组件 }, data() { reutrn { name: '你好呀', } } }); 注册组件 // 若使用extend 定义的组件注册时使用下面的方式 Vue.components({ component1: component1, }); // 另一种就是定义的同时就进行了注册，如上面的简化定义 使用组件 // 若组件定义且注册好后就可以在模板中使用了 // 注：组件在哪里注册了就只能在哪里使用，如：在子组件内注册了就不能在父组件内使用，反之在父组件内注册了是可以在子组件内使用的 模板抽离 在组件中把模板进行分离出来会使用逻辑更加的清晰 // 分离后的模板 你好呀，这是一个分离的模板 const app = new Vue({ el:'#app', data: { message: '我的消息' }, components:{ 'component1': { template: '#tep1', // 绑定分离的模板 } }, }); 问题：组件内的data为什么要是个函数呢？ 当一个组件在页面上多次使用时，每一个组件都有自己的data，若不是一个函数时，则就会使数据变乱而使数据交叉使用，而函数内部有自己的作用域。 4、父子组件 在子组件中是不能引用父组件或都Vue实例的数据的； 两种情况： 父传子： 通过props向子组件专递数据 子传父： 通过$emit event事件向父组件发送消息 a、父传子 // 父传子 /*父组件中使用v-bind来进行数据绑定到子组件上*/ /*在子组件内接收值的时候使用props关键字*/ Vue.component( 'component1': { // props: ['message', 'name', 'age'] props: { message: { type: String, // 类型 required: true, // 是否是必须的 default: 'jack' // 默认值 }, name: String, age: [String, Number] // 多种数据类型 } // 可以是一个数组或是一个对象 data() { return {} }, created: {}, methods: {}, }); props中的验证支持的数据类型有： String Number boolean Array 若有默认值时，那么默认值就需要是一个函数，函数的返回值是一个数组 Object 若有默认值时，默认值就需要是一个函数，函数的返回值是一个对象 Date Function 注： 在父向子传递参数的时候，使用全小写的驼峰的命名方式是不一样的哟 // 父组件传递值时要使用和中划线时，子组件才能以驼峰的方式来接收参数哟 // 在子组件内接收时，若使用驼峰时来接收时，父传递值时就要使用中划线来进行分隔，如：my-name Vue.component({ 'component1': { template: '#tpm', props: { myName: { // 此时的驼峰命名才是可以使用的 type: String }, myage:{ type: Number } }, data() { reutrn {} }, created: {} } }); b、子传父 需要用到自定义事件来传递值。v-on不仅仅可以用于监听DOM事件，也可以用于组件间的自定义事件。 注：在子组件内的事件名称最好不要使用驼峰命名，建议使用中划线（在脚手架内是可以使用驼峰的）。 在子组件内，通过使用$emit()来触发事件 在父组件内，通过v-on来监听子组件事件 // 在子组件内 Vue.component({ 'component1': { props: ['name'], methods: { getName() { var name = 'jack'; this.$emit('get-name', name); } } } }); // 在父组件内 通过v-on来监听子组件的事件，并绑定到自己的方法上做进一步的处理 const app = new Vue({ el: '#app', data() {}, methods: { getName(name) { consoel.log(name); // jack } } }); c、父组件访问子组件 $ref： vue中我们可以使用$ref来获取dom节点，进行一些dom的操作。 若使用在子组件上，可以用来获取子组件的属性（那么通过ref就能获取到子组件中的data和methods） 这是H1 // ref的使用 methods: { getRef () { this.$refs.h1Ele.style.color = 'red' // 修改html样式 console.log(this.$refs.ho.msg);// 获取组件数据 console.log(this.$refs.ho.test);// 获取组件的方法 } } 5、计算属性 computed其是被动的，若其所依赖的数据发生变动时其值就会发生变化。 特点： 支持缓存，只有依赖数据发生改变，才会重新进行计算。 不支持异步，当computed内有异步操作时无效，无法监听数据的变化。 computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值。 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，一般使用computed。 本质： funName() {set(),get()} 里面有set、get方法，但是set方法不常用通常会写成简洁的写法： // 这是简洁的写法 conputed: { getName: function() {}, getAge: function() {} } // 这是原始的写法 computed: { getName: { set() {}, get() {} }, getAge: { set() {}, get() {} } } 计算属性VS方法： 计算属性在多次使用时只会调用一次，而methods会多次调用 计算属性是自带缓存的，而方法是没有缓存的 6、侦听属性 watch其是主动的，若其本身发生变化时，可以在其方法内处理依赖它的其它数据，使其它数据随自身变化而变化。 特点： 支持缓存，数据变，直接会触发相应的操作。 watch支持异步。 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值。 当一个属性发生变化时，需要执行对应的操作，一对多关系。 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作。 watch: { name: function(newVlaue, oldValue) { console.log(newValue, oldValue) // newValue是新的数据，oldValue是旧的数据 } } 三、Vue路由 官方文档 前端路由，通过hash/history把单页面通过路由实现多页面 安装Vue-router npm install vue-router --save 在模块化工程中使用它(因为是一个插件，所以可以通过Vue.use()来安装路由功能) 导入路由对象且调用 Vue.use(VueRouter) 创建路由实例，并且传入路由映射配置 在Vue实例中挂载上一步创建的路由实例 使用路由 创建路由组件（也就是一个普通的组件） 配置路由映射（组件和路径映射关系） 使用路由：通过 和 两个组件来使用路由 router-link 该标签是一个vue-router内已经内置的组件，它会被默认渲染成一个标签 tag 可以指定router-link 渲染成什么标签 如：tag='li' 就会渲染成为li标签 replace 不会留下history记录，前进后退都不可用（history.replaceState） active-class 当对应的路由匹配成功时会自动的为当前元素添加一个对应的类名；如：active-class='active' router-view 该标签会根据当前的路径动态渲染出不同的组件，路由切换时，切换的是router-view挂载的组件，其它内容不会发生变化 // 和主入口文件同级创建router文件夹，之后在router文件夹内创建index.js文件作为路由文件 // index.js 文件内如： Vue.use(VueRouter) let routes: [ { path: '/', // 默认的首页是定向到home页 redirect: '/home' } { path: '/home', component: Home } { path: '/about', component: About } ] const router = new VueRouter({ mode: 'history', // 模式，默认是hash模式 routes, // 路由配置 linkActiveCalss: 'active' //当前路由选中时添加的类名 }) export default router // main.js 主入口文件内如： 首页 关于 1、$router $router是vue-router注册到全局的变量，可以使用$router直接进行操作路由跳转 $router是注册的整个路由对象，$route是当前活跃的路由对象 // 跳转到指定页面 this.$router.push('/home') // 相当于histroy.pushState() this.$router.replace('/about') // 相当于history.replaceState() 2、$route 表示当前活跃的那个路由，可以通过$route获取当前路由的参数 // 在注册路由时为路由动态的添加参数（router/index.js文件内） let routes: [ { path: '/user:userId', component: About } ] // 在user对应的组件内user.vue中获取路由的参数 console.log(this.$route.params.userId) // 获取到路由的参数 3、路由懒加载 路由懒加载的主要作用就是将路由对应的组件打包成一个一个js代码块，只有这个路由被访问到时才加载对应的组件。 使用懒加载可以提高首次加载时的效率。 // 使用路由懒加载（router/index.js文件内） Vue.use(VueRouter) const Usre = () => import('../component/User') // 实现路由懒加载 let routes: [ { path: '/user', component: User // component: () => import('../components/User') // 或这种方式 } ] const router = new VueRouter({ mode: 'history', // 模式，默认是hash模式 routes, // 路由配置 linkActiveCalss: 'active' //当前路由选中时添加的类名 }) // 打包时就会把每个路由对应的组件打包成单独的一个js代码块(命名为0.XXXXX.js 1.XXXXX.js 2.XXXXX.js .....) 4、子路由 子路由，也叫路由嵌套，采用在children后跟路由数组来实现，数组里和其他配置路由基本相同，需要配置path和component，然后在相应部分添加来展现子页面信息，相当于嵌入iframe。 // 在router/index.js文件内 Vue.use(VueRouter) const Usre = () => import('../component/User') // 实现路由懒加载 const UsreOne = () => import('../component/UserOne') // 实现路由懒加载 let routes: [ { path: '/user', component: User, children: [ { path: '', // 设置默认值 component: UsreOne }, { path: 'userOne', // 以“/”开头的嵌套路径会被当作根路径，所以子路由上不用加“/”;在生成路由时，主路由上的path会被自动添加到子路由之前，所以子路由上的path不用在重新声明主路由上的path了 component: UsreOne } ] } ] 5、参数传递 参数传递主要有两种方式：params和query params类型： 配置路由格式：/router/:id 传递方式：在path后面跟上对应的值 传递后形成路径：/router/123，/router/abc 获取参数值：$route.params.id query类型： 配置路由格式：就是普通的配置/router 传递方式：对象中使用query的key-value形式传递 传递后形成的路径：/router?id=123，/router?name=jack 获取参数值：$route.query.id $route.query.name // 第一种方式 params // 在注册路由时为路由动态的添加参数（router/index.js文件内） let routes: [ { path: '/user:userId', component: User } ] // 在user对应的组件内user.vue中获取路由的参数 console.log(this.$route.params.userId) // 获取到路由的参数 // 第二种方式：query // 在Home.vue组件内传递值时 关于 // 对to使用v-bind进行绑定值 // 获取参数值时 methods: { getName () { console.log($route.query.name) } } // 更多用法 // 不使用router-link进行跳转的情况： methods: { // 使用params方式 goUser () { this.$router.push('/user/' + 12) }, // 使用query方式 goHome () { this.$router.push({ path: '/home', query: { name: 'jack', age: 12 } }) } } 6、路由守卫beforeEach 或者叫 全局钩子 、导航守卫 用动态路由，判断用户是否登录跳转登录页面还是主页面，判断是否登录，判断页面是否存在，不存在跳转登录页面；或为每一个页面设置自己的title及keywords。优点是能适用多钟情况，体验感好。 全局前置守卫beforeEach：当一个导航触发时，路由跳转前执行的。 全局后置守卫afterEach：当一个导航触发时，路由跳转后执行的。 // 在route/index.js文件内操作 // to: Route: 即将要进入的目标 路由对象 // from: Route: 当前导航正要离开的路由 // next: Function: 一定要调用该方法使执行继续运行，next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。 const routes = [ { path: '/user:userId', component: User } ] router.beforeEach((to, from, next) => { // 此处可以进行一些值的获取，如：获取title、keywords并进行设置 // 也可以进行一些特殊逻辑的判断，如：对某个路由进行处理、或进行登录的验证 console.log(to); // 其是routes数组中定义的某个元素 console.log(from);// 其是routes数组中定义的某个元素 next(); // 一定要调用此方法，否则路由就会中断 }, // 全局后置守卫，但没有next参数 router.aftrEach((to, from) => { //同上面一样 } 7、路由独享钩子 给某个路由单独使用的，是特指的某个路由，一般定义在router当中。 beforeEnter：前置钩子函数，使用如：未登录去下单，跳转到登录页面 beforeLeave：后置钩子函数，使用如：改变浏览器title // 在route/index.js文件内操作，准确来说对定义的const routes进行操作 // to: Route: 即将要进入的目标 路由对象 // from: Route: 当前导航正要离开的路由 // next: Function: 一定要调用该方法使执行继续运行，next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。 const routes = [ { path: '/user:userId', component: User, beforeEnter: (to, from, next) => { // 此处可以进行一些值的获取，如：获取title、keywords并进行设置 // 也可以进行一些特殊逻辑的判断，如：对某个路由进行处理、或进行登录的验证 console.log(to); // 其是routes数组中定义的某个元素 console.log(from);// 其是routes数组中定义的某个元素 next(); // 一定要调用此方法，否则路由就会中断 }, beforeLeave: (to, from, next) => { // 此处可以进行一些值的获取，如：获取title、keywords并进行设置 // 也可以进行一些特殊逻辑的判断，如：对某个路由进行处理、或进行登录的验证 } } ] 8、组件路由钩子 监听页面进入，修改，和离开的功能。 beforeRouteEnter：页面路由进入时 beforeRouteUpdate：页面路由变更时 beforeRouteLeave： 页面路由离开时 // 组件路由是在各自己的组件内进行操作的，和created、method等属性并列 // 参数同上面一样 created: {}, computed: {}, method: {} beforeRouteLeave(to, from, next) { // .... next() }, beforeRouteEnter(to, from, next) { // .... next() }, beforeRouteUpdate(to, from, next) { // .... next() } 9、router-view遇见keep-alive 若不希望组件被重新渲染影响使用体验；或者处于性能考虑，避免多次重复渲染降低性能。而是希望组件可以缓存下来,维持当前的状态。这时候就可以用到keep-alive组件。 当组件在 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。 activated 和 deactivated 将会在 树内的所有嵌套组件中触发。 主要用于保留组件状态或避免重新渲染 使用场景：商品列表页点击商品跳转到商品详情，返回后仍显示原有信息；多级菜单下选中某个二级菜单再次回到菜单时还是原来的选中状态 补充：keep-alive有两个重要的属性 ​ 属性对应的值就是每个组件内的name名 include 字符串或正则表达式，只有匹配的组件会被缓存 declude 字符串或正则表达式，任何匹配的组件都不会被缓存 // 在某个组件内的模板中使用keep-alive export default { name: 'Dialog8', data () {}, created () { console.log('created') }, activated () { // 前提：当组件被keep-alive包裹时此方法才会生效 // 被调用时机：当前组件处于激活状态时 console.log('activated ...') }, deactivated () { // 前提：当组件被keep-alive包裹时此方法才会生效 // 被调用时机：当前组件从激活状态变为非激活状态时 console.log('deactivated ...') } } 四、promise Promise意在让异步代码变得干净和直观，让异步代码变得井然有序。Promise是一个构造函数，所以可以 new 出一个Promise的实例。 其有两个函数 resolve (成功之后的回调函数)和 reject (失败后的回调函数) 状态1：异步执行 成功，需要在内部调用成功的回调函数resolve把结果返回给调用者 状态2：异步执行 失败，需要在内部调用失败的回调函数reject把结果返回调用者 // 使用promise来进行异步的操作 // ####--> 第一种方式：在then里放置两个函数来处理成功和失败 new Promise((resolve, reject) => { // 假设setTimeout是异步的请求操作 setTimeout(function(){ const name = 'jack' if (name === 'jack') { // 成功时 resolve(name) } else { // 失败时 reject(name) } }, 1000) }).then(data => { // 成功时会执行 console.log(data) }, error => { // 失败时会执行 console.log(data) }) // ####--> 第二种方式：使用then catch 来处理成功和失败 new Promise((resolve, reject) => { // 假设setTimeout是异步的请求操作 setTimeout(function(){ const name = 'jack' if (name === 'jack') { // 成功时 resolve(name) } else { // 失败时 reject(name) } }, 1000) }).then(data => { // 成功时会执行 console.log(data) }).cache(data => { // 失败时选择 console.log(data) }) 1、promise链式调用 在使用中会发现无论是then还是catch都可以返回一个Promise对象，所以代码就可以进行链式调用了。 // #### ---> 链式调用的正常写法 new Promise((resolve, reject) => { // 假设setTimeout是异步的请求操作 setTimeout(function(){ resolve('promise') }, 1000) }).then(data => { // 成功时会执行 console.log(data) // promise return Promise.resolve(data + '111') }).then(data => { // 成功时会执行 console.log(data) // promise111 return Promise.resolve(data + '222') }).then(data => { // 成功时会执行 console.log(data) // promise111222 return Promise.reject(data + 'error') }).then(data => { // 这部分不会执行，因为上面的reject调用了 console.log(data) // 这一步不会执行 return Promise.reject(data + '333') }).catch(data => { // 失败时执行 console.log(data) // promise111222error return Promise.resolve(data + '444') }).then(data => { // 成功时会执行 console.log(data) // promise111222error4444 }) // #### ---> 链式调用的简化写法，可以把Promise.resolve省略了 new Promise((resolve, reject) => { // 假设setTimeout是异步的请求操作 setTimeout(function(){ resolve('promise') }, 1000) }).then(data => { // 成功时会执行 console.log(data) // promise return data + '111' }).then(data => { // 成功时会执行 console.log(data) // promise111 return data + '222' }).then(data => { // 成功时会执行 console.log(data) // promise111222 }) 2、promise的all方法 当一个页面可能有多个并发请求(异步请求)，我们想在所有请求完成后去处理一些逻辑，promise.all很好解决这个问题。 // 当一个页面有多个异步请求时，下面来模拟一下（如在methods方法内） methods: { init () { // 里面以数组的形式，可以放好多个异步请求哟 Promise.all([ // 这是第一个异步请求 new Promise((resolve, reject) => { setTimeout(() => { const data = {name: 'jack', age: 18} resolve(data) }, 3000) }), // 这是第二个异步请求 new Promise((resolve, reject) => { setTimeout(() => { const data = {name: 'rose', age: 17} resolve(data) }, 3000) }), ]).then(res => { console.log(res) // 此处的res为数组 [{name: 'jack', age: 18},{name: 'rose', age: 17}] }) } 五、vuex vuex是一个专门为Vue.js应用程序开发的状态管理模式 状态管理、集中式存储管理这些名词听起来高大上，让人捉摸不透。可以简单的将其看成，把需要多个组件共享的变量全部存储到一个对象里面（全局变量）核心也是使用Vue.prototype.paramName = paramValue 使用场景： 用户的登录状态、用户名、头像、地理位置 商品的收藏、购物车 1、state 状态管理工具的唯一的数据源，所有的共享数据都储存在里面（ 类似于组件内的data） 在组件内使用的时候方式：this.$store.state.数据名 // 使用vuex时和使用router是一样的步骤，因为同样都是插件 // 创建store文件夹，在其内创建index.js文件（这里写vux的内容） import Vue from 'vue' import Vuex from 'vuex' // 第一步：安装插件 Vue.use(Vuex) // 第二步：创建对象 const store = new Vuex.store({ // 状态管理工具的唯一的数据源，所有的共享数据都储存在里面（ 类似data） // 使用: 在组件内this.$store.state.数据名 state: { name: 'jack', count: 0, id: [23,34,45,56,78,89], info: { age: 18, // Vuex会为每一个值创建一个对应的Watcher来观察其变化，以便实现响应式 height: 1.88 // Dep => [Watcher1, Watcher2, ......] } }, // mutations使用与事件处理函数非常相似，都具有类型和回调函数(类似methods，不过获取state中的变量不是this.变量名，而是state.变量名) // 使用：在组件内this.$store.commit('方法名') mutations: { incrCount (state) { state.count++ } }, actions: {}, // getters属性类似组件中的计算属性（computed）,当数据被调用过且没发生改变时，之后的调用就到缓存区中找 // 使用：在组件内this.$store.getters.方法名 getters: { getAgeBy (state) { // 此处若有参数要返回一个函数来进行接收参数并进行处理 reutrn (age) => { return state.id.filter(i => i >= age) } }, // 第一个参数必为state,第二个参数必为getters getAgeLenght (state, getters) { return getters.getAgeBy(50).length }, getMultiParam (state) { reutrn (payload) => { console.log(payload) // 这是一个对象，内部有多个参数 } } }, modules: {} }) // 第三步： 导出store export default store // vuex注册到全局后就可以使用了（相当于Vue.prototype.$store = store） // 可以在各组件内使用$store methods: { getName () { const name = this.$store.state.name // 从Vuex中获取数据 console.log(name) }, addCount () { // 第一种方式 this.$store.commit('incrCount') // 调用Vuex中的方法 }, getAgeLg (age) { reutrn this.$store.getters.getAgeBy(age) // 调用Vuex中的方法并传递参数 return this.$store.getters.getMultiParam({name: 'jack', age: 14}) // 调用Vuex中的方法传递多个参数 } } 2、getters getters属性类似组件中的计算属性（computed）,当数据被调用过且没发生改变时，之后的调用就到缓存区中找 在组件内使用方式：this.$store.getters.方法名 getter内的方法有两个参数（且只能有两个参数） state 数据对象 getters 其本身的对象 若要携带参数时可返回一个匿名函数 getters: { // 获取年龄大于某个值的用户列表 getIdLt (state) { return (reload) { return this.id.filter(id => id >= reload) } } } // 在组件内使用 methods: { getId () { this.$store.getters.getIdLt(12) // 使用Vuex中的getters } } 3、mutations mutations使用与事件处理函数非常相似，都具有类型和回调函数(类似methods，不过获取state中的变量不是this.变量名，而是state.变量名) 结构组成： 字符串的事件类型（type） 一个回调函数（handler），该回调函数的第一个参数就是state 使用方式：在组件内this.$store.commit('方法名') 注：其是Vuex中对state值进行更新的唯一方式 建议：把mutations内的方法名写成常量的方式（在一个单独的文件内定义），这样就能更好的实现方法名的统一（减少多次写方法名） mutations: { addCount (state, payload) { state.count++ // payload(负载)是一个对象 // 第一种方式调用时 console.log(payload) // 12 // 第一种方式调用时 console.log(payload) // {type: 'addCount', count: 12} }, updateInfo (state, payload) { state.info.age = payload.age // 可以使用Vue内置的方式来变更值 Vue.set(state.info, 'age', payload.age) Vue.delete(state.info, 'age') }, // 此处可以以方括号的形式来把方法名变为常量 [FunName] (state) { cosole.log(state.name) } } // 在组件内使用 methods: { addCount () { // 第一种方式 this.$store.commit('addCount', 12) // 第二种使用方式 this.$store.commit({ type: 'addCount', count: 12 }) }, updateInfo () { this.$store.commit({ type: 'updateInfo', age: 19 }) }, test () { this.$store.commit(FunName) } } 4、actions 当有异步的数据时，需要把异步的请求放到actions内来处理，这样的目的是为人让devTool这个工具能够监听到数据的变化 mutations: { initData (state, payload) { console.log(payload) } }, actions: { // 第一种方式（普通） // 第一个参数为上下文，第二个参数为负载 getUrlData (context, payload) { setTimeout(() => { context.commit('initData') // 调用mutations里的方法 console.log() }, 1000) }, // 第二种方式（优雅） getUrldata1 (context, payload) { return new Promise((resolve, reject) => { setTimeout((res) => { context.commit('initData', payload) // 调用mutations里的方法 resolve(res) }, 1000) }); } } // 在组件内使用 methods: { testActions () { payload = {} // 对应第一种方式（普通） this.$store.despatch('getUrlData', payload) // 对应第二种方式（优雅） this.$store.despatch('getUrlData1') .then(res => { // 成功时 console.log(res) }) .catch(res => { // 失败时 console.log(res) }) } } 5、modules 当项目越来越大时，都在state/getter/mutations/actions里写时会显的很臃肿，这时使用modules进行模块的划分就是很有必要的了。 当要使用到根中的state时使用rootState 注：各模块中有mutations的名字不要和主中的一至 // 模块一 const modulesA = { state: {}, getters: { getM (state, getter, rootState) { // rootState可以获取根内的state数据 console.log(rootState.name) } }, mutations: {}, ... } // 模块二 const modulesB = { state: {}, getters: {}, mutations: {}, ... } // 在Vuex中的modules中关联多个模块 modules: { modulesA, // 相当于modulesA: mudulesA modulesB } // 在组件内使用模块 // state使用 this.$store.modulesA.属性名 // mutations使用,和主的是一样的用法 this.$store.commit('方法名') // getter使用，和主的是一样的用法 this.$store.getter.方法名 6、Vuex目录结构 若全部在一个文件内(stroe/index.js)写会使文件显的臃肿，可以对文件进行规划 store |----index.js # 组装模块并导出的地方 |----actions.js # 根级别的 action |----mutations.js # 根级别的 mutations |----modules |----modulesA.js # 模块A |----modulesB.js # 模块B ...... 六、axios axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端。 特点： 从 node.js 发出 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 请求方式： axios(config) axios.request(config) axios.get(url[,config]) axios.post(url[,data [,config]]) axios.delete(url[,config]) axios.head(url[,config]) axios.put(url[,data [,config]]) axios.patch(url[,data [,config]]) 1、安装 // npm安装到线上环境，因为上线后依然要使用 --save-dev为开发环境 npm install axios --save 2、使用 import axios from 'axios' // 最简单的使用 axios({ url: '接口链接', method: 'post', // 不写的话默认是get请求 params: { // 传递参数 name: 'jack', age: 18 } }).then(res => { console.log(res) // 接口返回的数据 }) // 假如有多个请求同时进行时（并发请求） axios.all([ axios.get({url: 'url1'}), axios.get({url: 'url2'}), ]).then(result => { console.log(result) // 返回一个数组 }) // 可以使用axios.spread将结果数组进行展开[res1,res2] ====> res1, res2 axios.all([ axios.get({url: 'url1'}), axios.get({url: 'url2'}), ]).then(axios.spread((res1, res2) => { console.log(res1) console.log(res2) })) 3、全局配置 开发中可能很多参数都是固定的（域名，请求头，超时时间，参数等），所以就可以对其进行一些抽离，使用axios的全局配置。 常用的配置： 请求地址：url 请求类型： method 请求路径：baseURL 自定义的请求头：headers URL查询对象：params --> 对应的get请求的参数 request body: data -----> 对应的是post的请求参数 axios.default.baseURL = 'https://melon.com' axios.default.timeout = 5000 axios({ url: '路径', }).then(res => { console.log(res) // 接口返回的数据 }) 4、axios实例 当有多个接口时（域名不一样），为了方便管理使用axios实例更为方便。 // 创建一个axios实例 const instance1 = axios.create({ baseURL: 'url1', timeout: 3000 }) // 使用实例 instance1({ url: '/path1', }).then(res => { console.log(res) }) instance1({ url: '/path2', }).then(res => { console.log(res) }) 5、对axios封装 有时候封装成一个工具是有必要的。 import axios from 'axios' // 第一种封装方式 export default request(config, success, faild) { // 创建axios实例 const instance = axios.create({ baseURL: 'url', timeout: 2000 }) instance(config) .then(res => { // 成功时 success(res) }) .catch(res => { // 失败时 faild(res) }) } // 第二种封装方式 export default request(config) { // 使用promise,并返回 return new Promise((resolve, reject) => { // 创建axios实例 const instance = axios.create({ baseURL: 'url', timeout: 2000 }) instance(config) .then(res => { // 成功时 resolve(res) }) .catch(res => { // 失败时 reject(res) }) }) } // 第二种方式在组件内使用 request({ url: 'url', }).then(res => { // 成功时 console.log(res) }) .catch(res => { // 失败时 console.log(res) }) // 第三种封装方式 export default request(config) { // 创建axios实例 const instance = axios.create({ baseURL: 'url', timeout: 2000 }) return instance(config) // 因为axios实例返回的是一个promise对象 } // 第三种封装方式在组件内的使用和第二种封装方式在组件内的使用是一样的 6、axios拦截器 拦截器可以让我们在每次请求前、得到响应后进行一些逻辑的处理。 发出请求时：instance.interceptors.request 获得响应时：instance.interceptors.response 作用： 可以在发出请求时带一些参数 可以在发出请求时设置header头信息 可以对获取响应数据时做一些逻辑处理 const instance = axiox.create({ baseURL: 'url', timeout: 2000 }) // 发出请求时的拦截 instance.interceptors.request.use(config => { console.log(config) // 发出请求时成功 reutrn config // 必须要返回config以便程度的继续执行 }, err => { console.log(err) // 发出请求时失败 }) // 获得响应时的拦截 instance.interceptors.response.use(response => { console.log(response.data) // 获得响应时成功 reutrn response.data // 必须要返回config以便程度的继续执行 }, err => { console.log(err) // 获得响应时失败 }) © 2021 易多客 京ICP备17028238号-1 all right reserved，powered by Gitbookmodify at： 2020-09-14 21:12:54 "},"tech/Flask框架基础.html":{"url":"tech/Flask框架基础.html","title":"Flask框架基础","keywords":"","body":"一、WEB开发框架 Python本身已经实现WEB服务的的接口(规范)，便于我们开发动态资源请求。提供的开始模块是wsgiref，此模块是其它高级框架中最核心的、最基本的规范，如Flask就是基于Werkzeug库实现的WSGI通信协议。 WSGI：Web Server Gateway Interface（Web服务网关接口），负责Http协议的底层通信。 WSGI实例： from wsgiref.simple_server import make_server dev app(environment, start_response): # 这里写核心业务逻辑哟 # 打印环境变量 # for k, v in environment.items(): # print(k, ':', v) # 环境变量内的内容 ''' 请求路径：PATH_INFO 请求方法：REQUEST_METHOD 请求参数：QUERY_STRING 客户端的地址：REMOTE_ADDR 服务器地址：HTTP_HOST 请求上传类型：CONTENT_TYPE 客户端的代理(浏览器)：HTTP_USER_AGENT ''' header = [('Content-Type', 'test/html')] body = ['Hello Python'.encode('utf-8')] # 生成响应的对象 start_response('HTTP/1.1 200 OK', header) return body host = '0.0.0.0' port = '5000' httpd = make_server(host, port, app) # 创建WEB服务 httpd.server_forever() # 启动Web服务 代码分析： - make_server()是创建WEB服务进程 - app()函数的env是environment的简写，表示请求的环境信息，是dist字典类型 - app()函数在返回之前，需要生成响应头信息即start_response('200 OK', [('header-key', 'header-value')]) 二、Flask框架的应用 1、安装环境 pip install flask -i https://mirrors.aliyun.com/pypi/simple 可以使用pip list或pip freeze命令来进行查看已经安装的包 2、Flask的简单使用 form flask import Flask # 创建Flask对象（Httpd Web服务） app = Flask(__name__) # 声明WEB服务的请求资源（指定资源访问的路由） @app.route('/home', methods=['GET', 'POST']) def home(): return 'Hello Python' # 启动FalsK的Web服务 app.run(host='localhost', port=8000, debug=false) # run更多参数的使用 ''' 主机，端口，调试模式(默认为false)，多线程(默认为false)，进程数(默认为1) 注：多线程和多进程是不可同时使用的，否则会报错哟 app.run(host='localhost',5000, True, threaded=True, processes=4) ''' 3、Flask中的MVC思想、MTV思想 MVC：Model + View + Controller MTV是基于MVC的，其中M为Model；T为Template；V为视图处理函数(Controller层) # 要导入模板，并且要创建一个名为templates的文件夹（一定要在项目的根目录创建哟），然后就可以在templates中创建模板文件啦 from flask import rander_template # 结合上面的示例添加一个新的路由 @app.route('/add', methods=['POST']) def addUser(): # 这里从Model中获取数据 data = { \"name\": \"jack\", \"age\": 12 } # 这里从模板中获取数据，第一个参数为模板名称，第二个参数为向模板传入的参数 html = rander_template('XXX.html', **data) # html = rander_template('XXX.html', name=\"jack\", age=12) # 这也是可以的哟 # 这里返回给客户端数据 return html 其中templates模板内的文件并不是静态网页文件，而是一个动态的模板文件，页面中存在动态显示的变量，需要在视图函数（controller）中指定数据渲染模板，渲染之后的html文件才是静态资源哟 4、获取GET/POST/日志数据 from flask import request, Flask app = Flask(__name__) @app.route('/add/', methods=['GET', 'POST']) def add(nid): # 接收uri参数 print(nid) # 获取POST内的数据 name = request.form.get('name', None) # 获取GET的数据 id = request.args.get('id', None) # 在控制台打印日志 app.logger.info(f'debug: name --> {name} id ---> {id}') app.run() 5、Template语法 5.1 for循环 在模板中rander_template('XXX.html', **data) 其中的data为字典类型 for循环要使用{% for i,v in xx.items()%} {%endfor%} 这种格式哟 如下： {% for i,v in userList.items() %} {{i}}、{{v.get('name')}}、{{v.name}}、{{v['name']}} {%endfor%} 5.2 rander_template函数 rander_template('XXX.html', **data) 其中data为关键字参数，关键字可为函数，如：rander_template('XXX.html', fun=fun1) 使用时{{fun()}} 6、配置文件 6.1、使用反射获取配置文件 配置文件中通常会使用utils.config.redis 的形式，其原理就是通过反射来获取其类并实例化 import importlib import settings # 其中有utils.config.redis.send def testFun(): for path in settings.CONF m,c = path.rsplit('.', maxsplit=1) # m为路径 c为类名 md = importlib.import_module(m) # md为导入的模块 obj = getattr(md, c)() # getatrr(md, c)为从模块中获取类 obj为实例化的对象 obj.send() # 此处就可以使用obj对象调用对应的方法了哟 7、路由系统 8、cookie&session Flask原生的session是把内容加密后放到cookie中(客户端的cookie的Key为\"session\"，其值为加密后的session内容) 使用flask-session组件时会生成随机字符串作为SessionID 当然也可以自定义来处理session的存储哟 请求刚到来时： 判断Cookie中是否有SessionID，若有则通过SessionID去“数据库”内取用户数据，否则创建一个随机字符串(SessionID)，并在内存中创建一个空容器，其格式如：对象（随机字符串：{存放数据的容器}） 处理视图函数时： 可操作内存中的对象，其格式如：对象（随机字符串：{存放数据的容器}） 做出响应时： 将内存中的对象保存到“数据库” 把随机字符串作为cookie的值设置到客户端cookie中 # Flask内默认的session接口 app.session_infterface = SecoureCookieSessionInterface() # 当然我们可以自定义，但自定义的类必须要有open_session()和 save_session() 这两个方法 app.session_infterface = MySession() # 使用第三方的Flask-session示例 #!/usr/bin/env python # -*- coding:utf-8 -*- \"\"\" pip3 install redis pip3 install flask-session \"\"\" from flask import Flask, session, redirect from flask.ext.session import Session app = Flask(__name__) app.debug = True app.secret_key = 'asdfasdfasd' app.config['SESSION_TYPE'] = 'redis' from redis import Redis app.config['SESSION_REDIS'] = Redis(host='192.168.0.94',port='6379') Session(app) @app.route('/login') def login(): session['username'] = 'alex' return redirect('/index') @app.route('/index') def index(): name = session['username'] return name if __name__ == '__main__': app.run() 9、请求&响应 10、闪现 应用场景：使用在提交信息或修改信息后返回到列表页时提示变更状态结果，也就是说从一个页面设置flash值在另一个页面取flash值有且只能取一次 form flask import Flask, falsh # 创建Flask对象（Httpd Web服务） app = Flask(__name__) app.secret_key = 'adfasfas' # 和session一样需要设置secret_key # 声明WEB服务的请求资源（指定资源访问的路由） @app.route('/home', methods=['GET', 'POST']) def home(): flash() # 设置值 return 'Hello Python' @app.route('/error', methods=['GET', 'POST']) def home(): # 获取值 return 'Hello Python' # 启动FalsK的Web服务 app.run(host='localhost', port=8000, debug=false) 11、蓝图 蓝图是什么？ 用于实现Flask框架中单个应用的视图，模板，静态文件的集合； 其也是一个存储操作(路由映射)方法的容器，这些操作在这个Blueprint 被注册到一个应用之后就可以被调用，Flask 可以通过Blueprint来组织URL以及处理请求（其实就是实现客户端的请求和URL相互关联的功能） 12、上下文 threading.local对象：用于为每一个线程开辟一块空间来保存它独有的值 threading.Local和Flask自定义Local对象的区别 Flask自定义的Local try: # 支持协程 from greenlet import getcurrent as get_ident # 协程 except ImportError: try: from thread import get_ident # 线程 except ImportError: from _thread import get_ident # 线程 class Local(object): def __init__(self): self.storage = {} # object.__setattr__(self, 'storage', {}) self.get_indent = get_ident # object.__setattr__(self, 'get_ident', get_ident) def set(self, key, value): ident = self.get_indent() origin = self.storage.get(ident) if not origin: origin = {key: value} else: origin[key] = value self.storage[ident] = origin def get(self, item): ident = self.get_indent() origin = self.storage.get(ident) if not origin: return None return origin.get(item, None) local_values = Local() def task(num): local_values.set('name', num) import time time.sleep(1) print(local_values.get('name'), threading.current_thread().name) for i in range(20): # 类似于有20个人同时进行并发访问 th = threading.Thread(target=task, args=(i,), name = '线程%s' % i) th.start() 请求到来时： 通过RequestContext类生成的对象做代理把请求的数据放到local类内存储起来 ctx = 封装RequestionContext(requst, session) ctx放到Local中 执行视图时： 通过LocalProxy类生成的对象做代理把local类内存储的请求数据获取出来在视图函数内使用 导入request print(request) --> LocalProxy对象的__str__ request.method --> LocalProxy对象的__getattr__ request +1 --> LocalProxy对象的__add__ 调用_lookup_req_object函数：去local中将requestContext对象获取到，再去requestContext中获取request、session 请求结束时： 把当前请求从local类内移除 ctx.auto_pop() ctx从local中移除 13、数据库链接池 方式一： SQLAlchemy(ORM) 方式二：PyMySQL(2/3)、MySQLDB(2) 14、信号 信号（signal）-- 进程之间通讯的方式，是一种软件中断。一个进程一旦接收到信号就会打断原来的程序执行流程来处理信号，信号是不能终止的哟。 Flask框架中的信号基于blinker，其主要就是让开发者可是在flask请求过程中定制一些用户行为。 组成部分： 要有信号（服务区） 信号内要有可执行的函数（食物） 要有请求执行（汽车） 辅助理解：一条从北京到上海的高速公路中，其间有20个服务区，每个服务区内都会提供食物，一辆汽车从北京开往上海，途径很多个服务区并进入服务区内就餐，最终达到目的地上海，之后买了上海的特产后返回北京 其中生命周期内有很多个勾子函数，勾子函数就是Flask内置的信号，其是信号的一种 14.1 内置信号 request_started = _signals.signal('request-started') # 请求到来前执行 request_finished = _signals.signal('request-finished') # 请求结束后执行 before_render_template = _signals.signal('before-render-template') # 模板渲染前执行 template_rendered = _signals.signal('template-rendered') # 模板渲染后执行 got_request_exception = _signals.signal('got-request-exception') # 请求执行出现异常时执行 request_tearing_down = _signals.signal('request-tearing-down') # 请求执行完毕后自动执行（无论成功与否） appcontext_tearing_down = _signals.signal('appcontext-tearing-down')# 应用上下文执行完毕后自动执行（无论成功与否） appcontext_pushed = _signals.signal('appcontext-pushed') # 应用上下文push时执行 appcontext_popped = _signals.signal('appcontext-popped') # 应用上下文pop时执行 message_flashed = _signals.signal('message-flashed') # 调用flask在其中添加数据时，自动触发 14.2 自定义信号 from flask import Flask, current_app, flash, render_template from flask.signals import _signals app = Flask(import_name=__name__) # 自定义信号 xxxxx = _signals.signal('xxxxx') def func(sender, *args, **kwargs): print(sender) # 自定义信号中注册函数 xxxxx.connect(func) @app.route(\"/x\") def index(): # 触发信号 xxxxx.send('123123', k1='v1') return 'Index' if __name__ == '__main__': app.run() 15、生命周期 16、Flask插件的使用 flask-script插件： 支持命令行控制项目脚本，命令参数是runserver 安装：pip install flask-script ```python 假如此文件在根目录中名叫server.py from 我的应用 import app # 这个就是之前上面声明APP的包哟 from flask_script import Manager if name == 'main': manager = Manager(app) manager.run() 之后就可以到此文件下执行命令 python server.py runserver -p 端口号 -h 主机名 -d(开启调试模式) -r(自动加载) ## 17、Flask_SQLAlchemy flask-SQLAlchemy是Flask和SQLAlchemy组合的管理者（其并不是SQLAlchemy本身，是对其进行了一层封装） **管理的内容：** - db = SQLALchemy() 创建一个db对象 - 包含SQLAlchemy所需要的配置信息 - 包含SQLAlchemy所需的ORM基类 - 包含create_all方法可以离线创建的数据库（必需把models导入到内存内，否则会找不到的哟） - 获取engine(单例) - 创建数据库会话链接(session) **使用：** ```python # from flask_sqlalchemy import SQLAlchemy # db = SQLAlchemy() # db.init_app(app) # 使用 添加一条数据 db.session.add(models.Rooms(name=\"002\", roomMax=12)) db.session.commit() # 提交操作 db.session.close() # 关闭链接（把链接还回到链接池内） # 查询数据 result = db.session.query(models.Rooms).all(); db.session.close() for item in result: print(item.name) 18、theadingLocal threading.local对象：用于为每一个线程开辟一块空间来保存它独有的值 import threading # local_values = Local() # threading.local() 可以保证每一个人来后为其单独的分配一个空间来存储其自己的数据 local_values = threading.local() def task(num): local_values.name = num import time time.sleep(1) # 延迟一秒后 print(local_values.name, threading.current_thread().name) for i in range(20): #此处相当于是20个人来进行同时并发请求的哟 th = threading.Thread(target=task, args=(i,), name = '线程%s' % i) th.start() 三、项目架构 1、目录结构 关键字参考： logic 逻辑层文件夹，以_logic.py 结尾 service 服务层文件夹，以_service.py 结尾 test 测试文件夹，以_test.py 结尾 helper 工具类的函数，以_helper.py 结尾 core 业务核心层目录 db 数据库处理层目录 common 公共层目录 static 静态资源文件目录 templates 模板文件目录 views（controllers） 视图函数文件目录 models 数据模型目录 utils 小工具类目录 migrations 数据库迁移目录 tests 单元测试目录 requirements.txt 依赖包的列表文件 manage.py 项目启动控制文件 config.py 全局配置文件，配置全局变量 main 程序模块，根据业务区分，不同的模块可以各自拥有自己的单独目录 application 应用程序目录 admin 后台系统业务目录 home 前台系统业务目录 项目结构： MyProject |--application |--main |--controllers |--api |--controllers |--templates |--main |--home |--index.html |--static |--images |--js |--css |--audios |--videos |--service |--logic |--dao |--models |--migrations |--tests |--common |--libs |--utils |--config |--appConfig.py |--uwsgiConfig.py |--nginxConfig.conf |--manage.py |--requirement.txt 2、响应规范 响应内容 可以使用 {\"code\":200,\"msg\":\"OK\",\"data\":{}} 3、RESTful规范 ========== ===================== ================================== HTTP 方法 行为 示例 ========== ===================== ================================== GET 获取资源的信息 http://example.com/api/orders GET 获取某个特定资源的信息 http://example.com/api/orders/123 POST 创建新资源 http://example.com/api/orders PUT 更新资源 http://example.com/api/orders/123 DELETE 删除资源 http://example.com/api/orders/123 ========== ====================== ================================== © 2021 易多客 京ICP备17028238号-1 all right reserved，powered by Gitbookmodify at： 2021-10-21 15:44:34 "},"tech/MySQL基础知识.html":{"url":"tech/MySQL基础知识.html","title":"MySQL基础知识","keywords":"","body":"MySQL的分层 链接层 –> 处理层 –> 引擎层 –> 存储层 SQL执行加载顺序 # 书写的SQL SELECT DISTINCT FROM JOIN ON WHERE GROUP BY HAVING ORDER BY LIMIT # 机读SQL的执行顺序 FROM ON JOIN WHERE GROUP BY HAVING SELECT DISTINCT ORDER BY LIMIT 七种JION理论 # A和B相交，取A的全部 SELECT FROM TableA A LEFT JOIN TableB B ON A.key = B.Key # A和B相交，取B的全部 SELECT FROM TableA A RIGHT JOIN TableB B ON A.key = B.Key # A和B相交，取相交部分 SELECT FROM TableA A INNER JOIN TableB B ON A.key = B.Key # A和B相交，取A内排除B的部分 SELECT FROM TableA A LEFT JOIN TableB B ON A.key = B.Key WHERE B.key IS NULL # A和B相交，取B内排除A的部分 SELECT FROM TableA A RIGHT JOIN TableB B ON A.key = B.Key WHERE A.key IS NULL # A和B相交，取两者的并集（mysql不支持FULL OUTER） SELECT FROM TableA A FULL OUTER JOIN TableB B ON A.key = B.Key WHERE B.key IS NULL # 使用union来实现(全A+全B 后union去重) FULL OUTER SELECT FROM TableA A LEFT JOIN TableB B ON A.key = B.Key union SELECT FROM TableA A RIGHT JOIN TableB B ON A.key = B.Key # A和B相交，取两都并集中排除交集的部分（mysql不支持FULL OUTER） SELECT FROM TableA A FULL OUTER JOIN TableB B ON A.key = B.Key WHERE A.key IS NULL OR B.key IS NULL # 使用union来实现(独A+独B 后union去重) FULL OUTER SELECT FROM TableA A LEFT JOIN TableB B ON A.key = B.Key WHERE B.key IS NULL union SELECT FROM TableA A RIGHT JOIN TableB B ON A.key = B.Key WHERE A.key IS NULL © 2021 易多客 京ICP备17028238号-1 all right reserved，powered by Gitbookmodify at： 2021-09-14 21:25:52 "},"tech/PHP进阶知识.html":{"url":"tech/PHP进阶知识.html","title":"PHP进阶知识","keywords":"","body":"一、变量 变量的作用域global/local/static global是全局变量，local是函数内局部变量，static是函数内局部变量 全局变量要是局部使用需要用global关键字 局部变量不能在全局使用 echo , print 和 print_r的区别: echo - 可以输出一个或多个字符串，没有返回值 print - 只能输出一个简单类型变量的值,如int,string，返回值为1 print_r - 可以输出一个复杂类型变量的值,如数组,对象 二、运算符 逻辑运算符: 运算符 名称 描述 实例 x and y 与 如果 x 和 y 都为 true，则返回 true x=6 y=3 (x 1) 返回 true x or y 或 如果 x 和 y 至少有一个为 true，则返回 true x=6 y=3 (x\\==6 or y==5) 返回 true x xor y 异或 如果 x 和 y 有且仅有一个为 true，则返回 true x=6 y=3 (x\\==6 xor y==3) 返回 false 三、php配置 php.ini文件内部分参数使用说明 1、安全参数 ;disable_function 设置禁用系统内的某些函数 disable_function=sysytem phpinfo exec mkdir ;expose_php是否在head头内显示php引擎信息(建议关闭) expose_php=Off ;register_argc_argv 使post get的参数都设置为全局变量（建议关闭） register_argc_argv=Off ;display_errors 不显示报错信息 display_errors = Off ;error_reporting 设置报错级别 error_reporting = E_ALL & ~E_DEPRECATED & ~E_STRICT ;开启日志记录 log_errors = On ;设置错误日志记录的文件地址 error_log = /data/web_logs/php_errors.log 2、资源参数 ;每个脚本运行的最大时长（秒）0表示没有限制；该指令只影响脚本本身的运行时长，花费在脚本之外的时间不计（如：sleep、数据库查询、） max_execution_time = 30 ;单个脚本能够申请到的最大内存，-1表示不进行限制 memory_limit = 512M ;开启文件上载 file_uploads = On ;上载文件大小限制 upload_max_filesize = 512M ;最大的文件上载数量 max_file_uploads = 50 ;禁远程使用url打开文件 allow_url_fopen = Off 四、php扩展 php常用的扩展 [PHP Modules] bcmath # bz2 calendar Core ctype curl date dom fileinfo filter ftp gd gettext hash iconv igbinary json libxml mbstring mcrypt memcached mysqli mysqlnd openssl pcntl pcre PDO pdo_mysql pdo_sqlite Phar posix redis Reflection session shmop SimpleXML soap sockets SPL sqlite3 standard sysvsem tokenizer wddx xml xmlreader xmlrpc xmlwriter yaconf Zend OPcache zip zlib [Zend Modules] Zend OPcache PHP8 新特性：视频 引用 Just-In-Time(JIT) Names Arguments Unin Types Constructor Property Promotion Null-Safe Operator Trailing Comma in Parameters Match Experssion Attributes WeakMaps Mixed Type Throw Exception From New Places Call::class on objects Non-Capturing Catch © 2021 易多客 京ICP备17028238号-1 all right reserved，powered by Gitbookmodify at： 2021-08-01 17:14:44 "},"tech/Python爬虫基础.html":{"url":"tech/Python爬虫基础.html","title":"Python爬虫基础","keywords":"","body":"一、爬虫流程 使用requests模块进行页面内容的获取，具体步骤： 指定url 发起请求 获取响应数据 数据解析 解析的局部的文本内容都会在标签之间或者标签对应的属性中进行存储 进行指定标签的定位 ----> 标签或标签对应属性中存储的数据值进行提取（解析） 持久化存储 二、XPath 常用且最便捷高效的一个解析方式之一，很且有通用性。 xpath解析原理： 实例化一个etree对象，且需要将被解析的页面源码数据加载到该对象中。 调用etree对象中的xpath方法结合着xpath表达式实现标签的定位和内容的捕获。 from lxml import etree import requests response = requests.get(url) pageText = response.text # 页面内容 tree = etree.HTML(pageText) # 实例化一个etree对象 tdList = tree.path('//div[@class=\"td-list\"]') # 通过xpath表达式获取内容 print(tdList) 1、xpath规则 a、xpath表达式 表达式可以实现标签的定位和内容的捕获 / 从当前节点选取直接子节点，或对当前节点进行操作；也代表着根节点 // 从当前节点选取后代节点，不考虑他们的位置 . 选取当前节点 .. 选取当前节点的父节点 @ 选取属性 tree.xpath('/bookstore') # 选取根元素 bookstore tree.xpath('bookstore/book') # 选取 bookstore 元素的直接子元素中的 book 元素 tree.xpath('//book') # 选取文档中的所有 book 元素 tree.xpath('./../div//span') # 选取 父级 元素中div下的所有后代 span 元素 tree.xpath('//@lang') # 选取文档中包含 lang 属性的所有元素 tree.xpath('//div/@class') # 选取文档中所有包含 class 属性的所有div元素 b、谓词 被嵌在方括号内，用来查找某个特定的节点或包含某个制定的值的节点 [数字] 获取第N个节点 [last()] 获取最后一个节点 [last()-1] 获取倒数第二个节点 [position() 获取前两个节点 [@class] 获取带有class属性的节点 [@class=\"list\"] 获取有class属性且属性值为list的节点 tree.xpath('/bookstore/book[1]') # 选取 bookstore 子元素中的第一个 book 元素 tree.xpath('/bookstore/book[last()]') # 选取 bookstore 子元素中的最后一个 book 元素 tree.xpath('/bookstore/book[last()-1]') # 选取 bookstore 子元素中的倒数第二个 book 元素 tree.xpath('/div/ul/li[position() c、通配符 Xpath通过通配符来选取未知的XML/HTML元素 * 获取所有的节点 [@*] 获取所有带属性的节点 tree.xpath('/bookstore/*') # 选取 bookstore 元素的所有子元素 tree.xpath('//*') # 选取文档中的所有元素 tree.xpath('//title[@*]') # 选取所有带有属性的 title 元素 d、运算符 使用|运算符可以选取多个路径 tree.xpath('//title | //span') # 选取文档中的所有 title 和 span 元素 e、文本 text() 获取节点中的文本 tree.xpath('//span/text()') # 获取节点中的文本 f、属性 attribute::href 获取当前节点的属性 href 的值 @href 获取当前节点的属性 href 的值 not() 获不含 class 属性的节点 or 或者的意思 and 并且的意思 tree.xpath('//div/a/attribute::href') # 获取当前a节点的属性 href 的值 tree.xpath('//div/a/@href') # 获取当前a节点的属性 href 的值 tree.xpath('//p[not(@class)]') # 选取不含 class 属性的所有 p 节点 tree.xpath('//p[not(@class or @id)]') # 选取不含 class 属性和 id 属性的所有 p 节点 e、轴 轴可以定义相对于当前节点的节点集 ancestor 选取当前节点的所有先辈节点（父、祖父） ancestor-or-self 选取当前节点的所有先辈节点以及节点本身 attribute 选取当前节点的所有属性 child 返回当前节点的所有子节点 descendant 返回当前节点的所有后代节点（子节点、孙节点） parent 选取当前节点的父节点 self 选取当前节点 tree.xpath('//div/a/ancestor::*') # 选取当前节点的所有先辈节点（父、祖父） tree.xpath('//div/a/ancestor-or-self::*') # 选取当前节点的所有先辈节点以及节点本身 tree.xpath('//div/a/attribute::*') # 选取当前节点的所有属性 tree.xpath('//div/a/child::*') # 返回当前节点的所有子节点 tree.xpath('//div/a/descendant::*') # 返回当前节点的所有后代节点（子节点、孙节点） tree.xpath('//div/a/parent::*') # 选取当前节点的父节点 tree.xpath('//div/a/self::*') # 选取当前节点 f、函数 使用功能函数能够更好的进行模糊搜索 start-with 选取XX属性值以MM开头的NN节点 contains 选取XX值包含MM的NN节点 and 选取XX值包含JJ和II的NN节点 contains(text(), 'MM') 选取节点文本包含MM的NN节点 tree.xpath('//div[start-with(@class, \"list\")]') # 选取class属性值以list开头的div节点 tree.xpath('/div//ul[contains(@id, \"an\")]') # 选取id值包含an的ul节点 tree.xpath('//div/li[conains(@id, \"an\") and contains(@id, \"li\")]') # 选取id值包含an和li的li节点 tree.xpath('//ul/a[contains(text(), \"melon\")]') # 选取节点文本包含melon的a节点 常用函数： 精确定位 contains(str1, str2) 判断str1是否包含str2 position() 选择当前元素的的第几个节点 last() 选择当前的倒数第几个元素 following-sibling 选择当前节点之后的所有同级节点 preceding-sibling 选取当前节点之前的所有同级节点 过滤信息 substring-before(str1, str2) 用于返回字符串str1中位于第一个str2之前的部分 substring-after(str1, str2) 跟substring-before类似，返回字符串str1中位于第一个str2之后的部分 normalize-space() 用来将一个字符串的头部和尾部的空白字符删除，如果字符串中间含有多个连续的空白字符，将用一个空格来代替 translate(string, str1, str2) 假如string中的字符在str1中有出现，那么替换为str1对应str2的同一位置的字符，假如str2这个位置取不到字符则删除string的该字符 拼接信息 concat() 用于串连多个字符串 ###### ---> 精确定位 # contains(str1,str2)用来判断str1是否包含str2 tree.xpath(\"//*[contains(@class,'c-summaryc-row ')]\") # 选择@class值中包含c-summary c-row的节点 tree.xpath(\"//div[contains(.//text(),'价格')]\") # 选择text()中包含价格的div节点 # position()选择当前的第几个节点 tree.xpath(\"//*[@class='result'][position()=1]\") # 选择@class='result'的第一个节点 tree.xpath(\"//*[@class='result'][position() 过滤信息 # substring-before(str1,str2)用于返回字符串str1中位于第一个str2之前的部分 tree.xpath(\"substring-before(.//*[@class='c-more_link']/text(),'条')\") # 返回.//*[@class='c-more_link']/text()中第一个'条'前面的部分，如果不存在'条'，则返回空值 # substring-after(str1,str2)跟substring-before类似，返回字符串str1中位于第一个str2之后的部分 tree.xpath(\"substring-after(.//*[@class='c-more_link']/text(),'条')) # 返回.//*[@class='c-more_link']/text()中第一个’条’后面的部分，如果不存在'条'，则返回空值 tree.xpath(\"substring-after(substring-before(.//*[@class='c-more_link']/text(),'新闻'),'第')\") # 返回.//*[@class='c-more_link']/text()中第一个'新闻'前面与第一个'第'后面之间的部分 # normalize-space() # 用来将一个字符串的头部和尾部的空白字符删除，如果字符串中间含有多个连续的空白字符，将用一个空格来代替 tree.xpath(\"normalize-space(.//*[contains(@class,'c-summaryc-row ')])\") # translate(string,str1,str2) # 假如string中的字符在str1中有出现，那么替换为str1对应str2的同一位置的字符，假如str2这个位置取不到字符则删除string的该字符 tree.xpath(\"translate('12:30','03','54')\") # 结果：'12:45' ###### ---> 拼接信息 # concat()函数用于串连多个字符串 tree.xpath(\"concat('http://baidu.com',.//*[@class='c-more_link']/@href)\") 三、多线程 四、协程 意义： 在一个线程中如果遇到IO等待时间时，线程不会傻傻的等，利用空闲时间再去做点其它的事。 1、greenlet 最早期的协程使用方式 from greenlet import greenlet # 需要安装greenlet库 def func1(): print(1) g2.switch() print(2) def func2(): print(3) g1.switch() print(4) g1 = greenlet(func1()) g2 = greenlet(func2()) g2.switch() # 输出结果为 3 1 4 2 2、yield关键字 def func1(): yield 1 yield from func2() yield 2 def func2(): yield 3 yield 4 f1 = func1() for f in f1: print(f) # 输出结果：1 3 4 2 3、asyncio 在Python3.4及其以后内置 import asyncio @asyncio.coroutine def func1(): print(1) yield from asyncio.sleep(2) print(2) @asyncio.coroutine def func2(): print(3) yield from asyncio.sleep(2) print(4) task = [asyncio.ensure_future(func1()),asyncio.ensure_future(func2())] # 创建事件循环对象 loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(task)) # 结果：1 3 2 4 4、async 和 await关键字 在Python3.5及其之后的版本中内置 async 协程函数 定义函数时使用async def 函数名 协程对象 执行协程函数后会得到一个协程对象（函数内部的代码是不会被执行的） 若要执行协程函数内的逻辑时，必须要将协程对象交给事件循环来处理。 await 后面跟上可等待的对象（协程对象、Future、Task对象--> IO等待），只能跟上这三种类型。 import asyncio # 协程函数 async def func1(): print(1) # 后面跟上IO等待 await asyncio.sleep(2) print(2) async def func2(): print(3) await asyncio.sleep(2) print(4) task = [asyncio.ensure_future(func1()),asyncio.ensure_future(func2())] # 创建事件循环对象 loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(task)) # 在Python3.中使用：run() # asyncio.run(asyncio.wait(task)) # 结果：1 3 2 4 示例：（使用协程对象来做为await 修饰的对象） import asyncio # 第一个协程对象 async def others(): print('start') await asyncio.sleep(2) return 'other complete.' # 第二个协程对象 async def func3(): print('func3 开始执行。。。') # 当遇到IO操作时，会自动挂起当前协程（任务），等IO操作完成后再继续往下执行，当协程挂起时事件循环可以去执行其它的协程（任务） otherResult = await others() print('func3 执行完成。。', otherResult) # 也可以再执行一次，等待。。。 otherResult1 = await others() print('func3 执行完成。。', otherResult1) loop = asyncio.get_event_loop() loop.run_until_complete(func3()) # 运行结果： # func3 开始执行。。。 # start # func3 执行完成。。 other complete. # start # func3 执行完成。。 other complete. 5、task 作用：在事件循环中添加多个任务 Task用于并发调度协程，通过asyncio.create_task(协程对象)的方式创建Task对象，这样可以让协程加入事件循环中等待被调度执行，除了使用asyncio.create_task()函数外，还可以使用低层级的loop.create_task()或asyncio.enture_future()函数，不建议手动实例化Task对象。 注意：asyncio.create_task()函数在Python3.7中被加入。在Python3.7之前，可以改用低层级的asyncio.ensure_future()函数。 import asyncio async def others(): print('start') await asyncio.sleep(2) return 'other complete.' async def func3(): print('func3 开始执行。。。') # 第一种方式： # task = [ # loop.create_task(others()), # loop.create_task(others()) # ] # 第二种方式： task = [ asyncio.ensure_future(others()), asyncio.ensure_future(others()) ] print('func3 已结束。。。') done, pending = await asyncio.wait(task, timeout=None) print(done, pending) loop = asyncio.get_event_loop() loop.run_until_complete(func3()) 5、Future Task 五、selenium 六、scrapy框架 © 2021 易多客 京ICP备17028238号-1 all right reserved，powered by Gitbookmodify at： 2020-11-21 14:15:10 "},"tech/TCT:IP基础知识.html":{"url":"tech/TCT:IP基础知识.html","title":"TCT:IP基础知识","keywords":"","body":"IP 1、IP基础知识 大致分为三大作用： IP寻址 IP地址属于网络层地址 路由（最终节点为止的转发） 是指将分组数据发送到最终目标地址的功能 以太网等数据链路中使用MAC地址传输数据帧，从源MAC地址到目标MAC地址之前传输的区间称为“一跳”，也就是说它是主机或路由器网卡不经其他路由器面能直接到达的相邻主机或路由器网卡之间的一个区间。 “多跳”是指路由器或主机在转发IP数据包时只能指定下一个路由器或主机，面不是将到最终目标为上的所有通路全都指定出来。 ```shell 多路示例（一个人出去旅游） 郑州 --> 石家庄 --> 北京 1、车站和工作人员 === 路由器 2、人相当于是IP数据包 3、出发地 === 源IP地址 4、目的地 === 目的IP地址 示例二 快递的运送 1、IP数据包 == 包裹 2、快递站点 == 路由器 3、货车 == 数据链路 （一个货车只能将包裹送到某个区间范围内） 4、出发地 === 源IP地址 5、目的地 === 目的IP地址 每一个路由器中都有一个路由表维护着IP数据在下一步应该发给哪一个路由器 网络：网段； 网络1 --> 路由器A 网络2 --> 路由器B 网络3 --> 路由器B ``` 数据链路也有一层抽象：当一个数据包太大，超过了最大的传输单位(MTU: Maxi-num Transmission Unit。就好比光纤和普通网线对比不同的快递公司邮寄包裹或行李时各自的大小限制一样)，就会进行拆包发送。 2、IP地址的基础知识 IP地址是由32位正整数来表示 10101100 00010100 00000001 00000001 （2进制） 172 . 20 . 1 . 1 (10进制) IP地址 = 网络地址 + 主机标识 192.168.128.10/24 中的192.168.128为网络地址(也就是2进制的前24位) 最后一位为主机标识 IP地址分类 A类：0.0.0.0 ~ 127.0.0.0 如：0.1.1.1.1/8 B类：128.0.0.1 ~ 191.255.0.0.0 如：128.1.1.1/16 C类：192.168.0.0 ~ 239.255.255.0 如：192.168.2.3/24 D类：224.0.0.0 ~ 239.225.225.225 其没有主机标识，常用于多播 一台主机至少可以设置一个以上的IP地址。 一台路由器可以设置两个以上的IP地址。 一块网卡也可以设置两个以上的IP地址。 © 2021 易多客 京ICP备17028238号-1 all right reserved，powered by Gitbookmodify at： 2021-08-30 07:27:06 "},"tech/rsync基础知识.html":{"url":"tech/rsync基础知识.html","title":"rsync基础知识","keywords":"","body":"rsync 文件时实同步工具 选项： -p 复制文件过程中保持文件的属性不变 -v 显示复制过程信息 -a 使用归档模式（如复制目录必须使用些选项） -z 在传输过程中以压缩方式进行传输 工作模式一 使用local模式，同步本地文件到本地其它目录。 格式：rsync [OPTION]... SRC [SRC]... DEST 工作模式二 通过远程shell访问，可以拉取远程信息，也可以把本地信息推送到远程。 在文件传递过程中，会首先对比源文件和目的文件的特征码，只有当特征码不一样的时候才会进行传递。 工作中最常用的是rsync+ssh密钥认证方式，目的是为了免密登录。 格式： rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST rsync [OPTION]... [USER@]HOST:SRC [DEST] 配置文件 默认的配置文件名为rsyncd.conf 此配置文件默认是没有进行创建的（默认的路径为/etc/rayncd.conf） rsyncd.conf配置文件的基本构成： 全局参数 ..... [模块1] 模块参数 .... [模块2] 模块参数 .... 全局参数 pid file：指定rsync进程的pid文件的路径和名称 lock file：指定rsync进程锁文件的路径和名称 log file：rsync日志文件路径和名称 模块参数 可以写在全局部分，如果写在全局部分，则对所有的模块都生效。 path：指定备份目录的路径 use chroot：是否将用户锁定在家目录中（用户只能在其家目录内才能进行同步文件） max connections：指定可以进行同时链接的最大用户数 read only：本模块只读 write only：本模块只可写 list：设置是否可以显示全部的模块列表 auth users：指定访问模块时需要使用的用户名，这里的用户是虚拟用户（不存在于/etc/passwd内） secrets file：指定保存虚拟用户名和密码的数据文件（其文件权限必须为600） host allow：指定可以访问rsync模块的IP地址 host deny：黑名单 exclude：要指定排除的文件列表，列表中的内容以空格为分隔符 补充： host allow 和host deny的使用 两个参数都没有的时候，那么所有的用户都可以随意访问 只有allow时，仅仅允许白名单的IP进行访问 只有deny时，仅仅允许黑名单内的IP进行访问 两个参数都存在时，优先使用白名单，之后再使用黑名单，若都不存在于两个内，则允许其访问模块 使用步骤 rsync服务端设置 创建rsyncd.conf配置文件 uid = rsync gid = rsync use chroot = no max connections = 100 tiemout = 60 pid file = /var/lock/rsync.pid lock file = /var/lock/rsync.lock log file = /var/log/rsync.log [mod1] path = /path/to/youdir read only = false hosts allow = 10.0.0.0/24 list = false 创建目录 mkdir -pv /path/to/youdir 创建运行rsync的系统用户 groupadd -r rsync useradd -r -s /sbin/nologin -g rsync rsync 启动rsync rsync --deamon # 使用后台守护进程的方式进行启动 # 若要指定配置文件则使用 --config rsync --deamon --config=/path/to/you/config rsync客户端使用 格式： rsync [options] /path/ [user@]host::modulename[/path/] rsync [options] [user@]host::modulename[/path/] /path/ 如：rsync -avz /home/ vuser1@109.04.04.0::mod1/home/ –passwd-file=/etc/rsync.passwd 高级用法: –passwd-file 指定虚拟用户的密码 –delete 服务端的文件和客户端完全一致（客户端上传时，若服务端上存在客户端上没有的文件则删除） –exclude 在进行文件传输的时候，排除指定的文件 # 方式一：排除一个文件 --exclude=file # 方式二：排除多个文件 --exclude={file1,file2} # 方式三：通配符方式 --exclude=*.php rsync小结 服务端配置： 创建配置文件rsyncd.conf 创建密码文件并设置权限为600（若用不到则不进行填写） 创建系统用户（用于以守护进程的方式运行rsync） 创建模块对应的目录，修改目录的属主属组为系统用户 以deamon的形式启动 客户端配置： 创建虚拟用户的密码文件并把文件权限设置为600（若需要时进行设置） 向模块传递文件或者从目录内拉取文件 © 2021 易多客 京ICP备17028238号-1 all right reserved，powered by Gitbookmodify at： 2021-08-12 07:29:16 "},"tech/Go基础知识.html":{"url":"tech/Go基础知识.html","title":"Go基础知识","keywords":"","body":"一、开发环境 1、配置 在电脑上新建一个目录，来存放编写的Go语言代码（编译目录） 在环境变量里添加Go（mac不需要处理） 在新建的目录内建三个文件：src,pak,bin 使用命令查看Go版本号go version 使用命令查看环境变量go env 2、跨平台 windows下编译一个linux下可执行文件 SET CGO_ENABLED=0 // 禁用CGO SET GOOS=linux // 目标平台是linux SET GOARCH=amd64 // 目标处理器架构是amd64 Mac 下编译 Linux平台 64位 CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build Mac 下编译Windows平台 64位 CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build Windows下编译Mac平台64位 SET CGO_ENABLED=0 SET GOOS=darwin SET GOARCH=amd64 go build 3、开发命令 go build（常用） go run（不常用） go install(不常用) 二、基础语法 1、变量 非全局变量在声明后必须要使用，不使用则编译不过去 声明变量时Go会自动对变量的内存区进行初始化，每个变量会被初始化成其类型的值（整型为0，布尔为false等） 可以在声明的时候为其指定初始值或初始化多个变量 // var 变量名 类型 = 表达式 // 声明变量同时赋值 var name string = \"jack\" var age, nick = 20, \"rose\" // 类型推导（根据值来判断该变量是什么类型） var str1 = \"string01\" // 简短变量声明 str2 := \"string02\" // 批量声明 var ( str3 string age1 int ) str3 = \"melon\" age1 = 21 println(name) println(age, nick) println(str1) println(str2, str3, age1) 匿名变量 在使用多个变量赋值时，如果想忽略某个变量，可以使用匿名变量(anonymous variable)匿名变量是用一个下划线来_表示，其不占用内存空间所以不存在重复声明 func foo() (int, string) { return 23, \"yeah\" } // 匿名变量 _, name3 := foo() println(name3) 注意事项 函数个的每个语句都必须以关键字开始（var 、const、func等） := 不能在函数个使用 _ 多用于占位符，表示忽略值 在同一个作用域内一个变量名不能重复的定义 2、常量 相对于变量，常量是相对不变的值，多用于定义程序运行期间不会变的值 // 单个常量的定义 const pi = 3.14 // 多个常量的定义 const ( m = 3 n // 多个常量定义时，若省略了值则和上面一行的值相同 e = 4 f ) println(pi, m, n, e, f) iota 是go语言的常量计数器，只能在常量的表达式中使用。在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。 // 单个常量的定义 const pi = 3.14 // 多个常量的定义 const ( m = 3 n // 多个常量定义时，若省略了值则和上面一行的值相同 e = 4 f ) // iota --> 0 1 2 const ( a1 = iota a2 a3 = iota ) // 跳过某个值 ---> 0 3 const ( b1 = iota _ _ = iota b3 = iota ) // 插值 --> 0 100 100 3 4 const ( c1 = iota c2 = 100 c3 c4 = iota c5 ) // 示例 ---> 1024 1048576 1073741824 1099511627776 1125899906842624 const ( _ = iota KB = 1 3、数据类型 Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等 a、整型 整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64 // 而且还允许我们用 _ 来分隔数字，比如说： v := 123_456 表示 v 的值等于 123456。 int1 := 23 int2 := 123_456 println(int1, int2) b、浮点型 Go语言支持两种浮点型数：float32和float64。 import \"fmt\" import \"math\" fmt.Printf(\"%f\\n\", math.Pi) fmt.Printf(\"%.2f\\n\", math.Pi) c、布尔型 Go语言中以bool类型进行声明布尔型数据，布尔型数据只有true（真）和false（假）两个值。 注意： 布尔类型变量的默认值为false。 Go 语言中不允许将整型强制转换为布尔型. 布尔型无法参与数值运算，也无法与其他类型进行转换。 d、字符串 Go语言中字符串使用双引号来包括起来，单引号包括起来的是单个字符而不是字符串 常用的转义字符 \\r 回车符（返回行首） \\n 换行符（直接跳到下一行的同列位置） \\t 制表符 \\' 单引号 \\\" 双引号 \\\\ 反斜杠 多行字符串 要定义一个多行字符串时，就必须使用反引号字符 s1 := `第一行 第二行 第三行 ` fmt.Println(s1) 4、流程控制 a、if条件 Go语言规定与if匹配的左括号{必须与if和表达式放在同一行，{放在其他位置会触发编译错误。 同理，与else匹配的{也必须与else写在同一行，else也必须与上一个if或else if右边的大括号在同一行。 // 若在条件1前面写上初始值的话，此值只会在if条件体内使用（是局部变量） if a := 1;条件1 { 语句1 } else if 条件2 { // else 和 if之间必须要有空格分离 语句2 } else { 语句3 } b、for循环 Go内没有while循环，可以使用for来实现相同的功能（见用法三） /* 基本语法 for 初始语句;条件表达式;结束语句{ 循环体语句 } */ // 第一种用法 for i := 1; i 键值循环 for _,v := range \"hello\" { fmt.Printf(\"%c %T\\n\", v, v) } c、for range Go语言中可以使用for range遍历数组、切片、字符串、map 及通道（channel）。 通过for range遍历的返回值有以下规律： 数组、切片、字符串返回索引和值。 map返回键和值。 通道（channel）只返回通道内的值 for _,v := range \"hello\" { fmt.Printf(\"%c %T\\n\", v, v) } d、switch case 使用switch语句可方便地对大量的值进行条件判断。Go语言规定每个switch只能有一个default分支。 // 分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量。 s := 3 switch { case 0 e、退出循环 goto语句通过标签进行代码间的无条件跳转。goto语句可以在快速跳出循环、避免重复退出上有一定的帮助。适用于for、switch和select的代码块，后可跟结束后跳转出的标签 break语句可以结束for、switch和select的代码块，后可跟结束后跳转出的标签，标签要求必须定义在对应的for、switch和 select的代码块上。 continue语句可以结束当前循环，开始下一次的循环迭代过程，仅限在for循环内使用。后可跟结束后跳转出的标签，标签要求必须定义在对应的for代码块上。 5、数组 数组是同一种数据类型元素的集合。 数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 定义： var 变量名 [数组长度]变量类型 // 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变 // [5]int和[10]int是不同的类型 var int1 [5]int var int2 [10]int printf(int1[0]) // 数组可以通过下标进行访问,访问越界会panic 初始化： 方法一 使用初始化列表来设置元素的值 var testArray [3]int //数组会初始化为int类型的零值 var numArray = [3]int{1, 2} //使用指定的初始值完成初始化 fmt.Println(testArray) //[0 0 0] fmt.Println(numArray) //[1 2 0] 方法二 一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度 var testArray [3]int var numArray = [...]int{1, 2} var cityArray = [...]string{\"北京\", \"上海\", \"深圳\"} fmt.Println(testArray) //[0 0 0] fmt.Println(numArray) //[1 2] fmt.Printf(\"type of numArray:%T\\n\", numArray) //type of numArray:[2]int fmt.Println(cityArray) //[北京 上海 深圳] fmt.Printf(\"type of cityArray:%T\\n\", cityArray) //type of cityArray:[3]string 方法三 我们还可以使用指定索引值的方式来初始化数组 a := [...]int{1: 1, 3: 5} fmt.Println(a) // [0 1 0 5] fmt.Printf(\"type of a:%T\\n\", a) //type of a:[4]int 6、切片 7、map 8、函数 © 2021 易多客 京ICP备17028238号-1 all right reserved，powered by Gitbookmodify at： 2021-02-26 07:31:18 "},"tech/Nginx基础知识.html":{"url":"tech/Nginx基础知识.html","title":"Nginx基础知识","keywords":"","body":"一、前置认识 官网：Nginx 1、优势 高性能： 处理高并发能力很强（IO 模型：Nginx epoll模型；apache select 模型） 高扩展性： 模块化的程序，根据企业业务需求添加响应模块 高可用： 多台服务中，若有某台服务挂掉时，会备用的的服务立即替补来保证服务正常运行（三个9、四个9、五个9） 支持热部署： nginx版本平滑升级（不影响对外提供服务） 2、应用场景 静态资源服务： web服务 负载均衡： 实现集群化管理 代理服务： 将动态资源请求（第二次进行缓存）转发给 FastCGI —》 后端语言 –》数据库 安全控制： 针对用户访问进行权限控制，https加密处理的安全认证，结合Lua语言实现waf防护（网页防火墙） 二、安装 1、编译安装方式 # 安装前的依赖添加 yum install -y openssl-devel pcre-devel gcc # 预编译(重要参数): [参考链接](http://nginx.org/en/docs/configure.html) --prefix=path 定义将保存服务文件的目录。这个相同的目录也将用于由configure（库源的路径除外）和nginx.conf配置文件中设置的所有相对路径 。/usr/local/nginx默认设置为目录。 --sbin-path=path 设置 nginx 可执行文件的名称。此名称仅在安装期间使用。默认情况下，文件名为 prefix/sbin/nginx. --modules-path=path 定义将安装 nginx 动态模块的目录。默认情况下使用prefix/modules目录。 --conf-path=path 设置nginx.conf配置文件的名称。如果需要，nginx 始终可以使用不同的配置文件启动，方法是在命令行参数中指定它 。默认情况下，文件名为 . -c fileprefix/conf/nginx.conf --error-log-path=path 设置主要错误、警告和诊断文件的名称。安装后，始终可以nginx.conf使用error_log指令在配置文件中 更改文件名 。默认情况下，文件名为 prefix/logs/error.log. --pid-path=path 设置nginx.pid将存储主进程的进程 ID的文件的名称。安装后，始终可以nginx.conf使用pid指令在配置文件中 更改文件名 。默认情况下，文件名为 prefix/logs/nginx.pid. --lock-path=path 为锁定文件的名称设置前缀。安装后，始终可以nginx.conf使用lock_file指令在配置文件中 更改该值 。默认情况下，该值为 prefix/logs/nginx.lock。 --user=name 设置非特权用户的名称，其凭据将由工作进程使用。安装后，始终可以nginx.conf使用user指令在配置文件中 更改名称 。默认用户名是nobody。 --group=name 设置工作进程将使用其凭据的组的名称。安装后，始终可以nginx.conf使用user指令在配置文件中 更改名称 。默认情况下，组名设置为非特权用户的名称。 ./configure --prefix=/usr/local/nginx --sbin-path=/bin/ --user=www --group=www --with-http_ssl_module --with-http_stub_status_module --with-http_gzip_static_module --with-http_v2_module --with-http_realip_module # 添加设置好的用户(若用户已经存在则不需要添加) adduser www -m -s /sbin/nologin # 编译安装 make && make install # 启动服务 /bin/nginx 2、自动化安装 使用Contos带的自动化管理工具yum 方式参考 yum安装nginx # 配置yum源 sudo yum install yum-utils touch /etc/yum.repos.d/nginx.repo # 添加yum源到文件内 /etc/yum.repos.d/nginx.repo [nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true [nginx-mainline] name=nginx mainline repo baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/ gpgcheck=1 enabled=0 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true 3、命令 查看安装后的命令 # 查看安装信息 /usr/local/nginx/sbin/nginx -V © 2021 易多客 京ICP备17028238号-1 all right reserved，powered by Gitbookmodify at： 2021-07-26 07:12:52 "},"tech/Python基础知识.html":{"url":"tech/Python基础知识.html","title":"Python基础知识","keywords":"","body":"一、数据类型 1、变量 变量在使用前一定要先声明 age = 0 变量名组成由：字母、数字、下划线组成且不能以数字开头 不能使用“关键字” 变量的删除使用 del age 查看变量的类型使用 type(age) 查看变量的地址使用 id(age) 交换变量的值： a, b = 1, 2 a, b = b, a print(a) # 2 print(b) # 1 2、输出 格式化输出：print('我的年龄是%d，名字是%s' % (18, 'jack')) 第一种方式：%s、%d、%f、%06d、%.2f 第二种方式：f{表达式} 如：print(f\"我的名字是{name}\") print(\"输出的内容\", end=\"\\n\")；可以自定义结束符号哟 3、输入 input(\"输入的内容\")；接收到的数据类型都是字符串 4、各类型的常用内置方法 字符串 a、切片 是指对操作的对象截取其中一部分的操作，字符串、元组、列表都支持切片的操作 格式：序列[开始位置下标:结束位置下标:步长] 注意： ​ 不包含对其位置下标对应的数据，正负整数均可，步长是选取间隔，正负数均可，默认步长为1 b、函数 str.capitalize() #字符串首字符转换为大写 str.title() #把字符串中的每个单词的首字符转换为大写 'hello world'.title() # 'Hello World' str.istitle() #判断一个字符串中是否是每个单词都是首字符大写，返回值为boolean str.upper() #将当前字符串转换为大写 'hello world'.upper() # 'HELLO WORLD' str.isupper() #是否是大写，返回值为boolean str.lower() #将当前字符串转换为小写 'HELLO WORLD'.lower() # 'hello world' str.islower() #是否是小写，返回值为boolean str.find(searchStr, begin=0, end=len(str)) #返回第一次出现的索引值，否则返回-1 'hello world'.find('d') # 10 str.rfind()、str.lfind() #从字符串的左右开始查找 str.index(searchStr, begin=0, end=len(str)) #和find使用方法一致，不同的是没有找到会报错 str.rindex()、str.lindex() #了解就可以 str.replace(old, new [, max]) #把旧的换成新的最多max次 'hello world'.replace('world', '我的') # 'hello 我的' str.center(width, fillchar) 将字符串居中，居中后的长度为 width width: 表示字符串总长度 fillchar: 使字符串居中所填充的字符，默认为空格 str.count(sub, start=0, end=len(string)) 返回该字符串中出现某字符串序列（或字符）的次数 sub: 被查找的字符串序列 start: 开始查找的索引位置，默认为字符串开始 end: 结束查找的索引位置，默认为字符串结束 返回值：被查找的序列在字符串的查找位置中出现的次数 'hello world'.count('o') # 2 str.decode(encoding=’UTF-8’,errors=’strict’) encode(encoding=’UTF-8’,errors=’strict’) 使用特定编码将字符串解码(decode)/编码(encode) str.endswith(suffix, start=0, end=len(string)) 判断字符串是否是以某字符串结尾的 suffix: 被查找的字符串 start: 字符串查找的起始位置，默认为字符串起始位置 end: 字符串查找的结束位置，默认为字符串结束位置 'hello world'.endswith('d') # True str.isalnum() 判断该字符串是否只是字母数字组合 str.isalpha() 判断该字符串是否是字母组合 str.isdigit() 判断该字符串是否只包含数字 tag.join(seq) 用该字符串连接某字符序列(seq) '-'.join(['hello', 'world']) # hello-world str.len(string) 得到该字符串的长度 str.format() 增强的字符串格式化功能 示例：\"name：{name}, job: {job}\".format(name=\"link\", job=\"hero\") lstrip() & rstrip() & strip() 移除字符串左边/右边/左右两边的指定字符串，默认为空格。 str.split(tag) 分割函数 'hello-world'.split('-') # hello world c、格式化 第一种： '%s, %d, %u, %f' % ('jack', -12, 13, 0.98) # 'jack, -12, 13, 0.980000' 第二种： name = 'jack'; age = 12 print(f'name:{name}; age:{age}') # name:jack; age:12 第三种（常用）： '{1}, {0}, {1}'.format('hello', 'world') # 'world, hello, world' '{name}, {age}'.format(name='jakc', age=12) # 'jakc, 12' # 对数字的格式化 '{:.2f}'.format(3434.343) # 浮点型数据保留两位有效小数 3434.34 '{:,}'.format(10000000) # 格式化金额，添加逗号 '10,000,000' '{:.2%}'.format(233.2455) # 保留两位有效数字，并转换为百分制 '23324.55%' '{:0>8}'.format(23) # 不足8位时使用0来在左侧进行补全至8位 '00000023' '{:x 列表 以一个方括号内的逗号分隔值组成，列表的数据项不需要具有相同的类型，且是可以重复的哟~ a、切片 是一个容器，存放多个字符串、整型等其它类型 下标从0开始，最后一个下标是-1 # 定义一下列表 li = ['hello world', 23, 0.98, True, None, ('rose', 'jack')] # 切片使用 li[:] # ['hello world', 23, 0.98, True, None, ('rose', 'jack')] li[1:4] # [23, 0.98, True] li[:-1] # ['hello world', 23, 0.98, True, None] li[-1:] # [('rose', 'jack')] li[len(li) - 1] # ('rose', 'jack') li[3] # True li[:6:2] # ['hello world', 23, 0.98, True, None, ('rose', 'jack')] li[-1:-5:-1] # [('rose', 'jack'), None, True, 0.98] li[-5:-1:1] # [23, 0.98, True, None] li[::-1] # [('rose', 'jack'), None, True, 0.98, 23, 'hello world'] # 两个列表进行相加 li1 = [123,4,5]; li2 = [6,7,7,89] li1 + li2 # [123, 4, 5, 6, 7, 7, 89] # 一个列表的乘法 li1 * 4 # [123, 4, 5, 123, 4, 5, 123, 4, 5, 123, 4, 5] b、函数 len(list) 查看列表的长度 print(len(['jack', 'rose', 'luck'])) # 3 max(list) 获取列表内最大的值，前提是列表内的值要是同一种类型的哟 min(list) 获取列表内最小的值，前提是列表内的值要是同一种类型的哟 list(tuple) 将元组转换为列表 c、方法 list.insert(index, obj) 在列表index位置插入一个obj元素， 无返回值 list.extend(list2) 列表末尾一次性追加另一个序列中的多个值，无返回值 list.append(obj) 在列表末尾添加一个元素， 无返回值 list.pop([index=-1]]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 list.remove(obj) 移除列表中某个值的第一个匹配项，没有返回值 list.reverse() 反向列表中元素，没有返回值 list.sort() 对列表进行排序 list.count(obj) 统计某个元素在列表中出现的次数 元组 其与列表类似，可以重复，不同之处在于元组的元素不能修改 a、切片 可以使用切片 b、函数/方法 对元组进行查询、删除 # 声明一个元组 tu = ('jack', 23, 'a', 'b', 0.98, True, None) tu.count('a') # 1 len(tu) # 7 'jack' in tu # True # 两个元组进行相加 tu1 = ('a', 'b', 'c') tu2 = ('jack', 'rose', 'luck') tu1 + tu2 # ('a', 'b', 'c', 'jack', 'rose', 'luck') # 删除一个元组 del(tu1) # 把可迭代的转换为元组 li = ['jack', 'rose', 'a', 23] tu3 = tuple(li) # ('jack', 'rose', 'a', 23) 字典 特点： 可变容器模型，且可存储任意类型对象。 字典的每个键值 key=>value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中。 其键是唯一的，其值可以不唯一。 值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。 a、函数 len(dict1) 获取字典的长度 str(dict1) 输出字典可打印的字符串表示 b、方法 dict1.clear() #删除字典内所有元素 dict1.copy() #返回一个字典的浅复制 dict1.fromkeys() #创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值 # 声明一个tuple tu = ('刁', '海', '强') dict.fromkeys(tu, '完美') # {'刁': '完美', '海': '完美', '强': '完美'} dict1.get(key, default=None) #返回指定键的值，如果值不在字典中返回default值 dict1.__contains__(key) #如果键在字典dict里返回true，否则返回false 注：has_key在Python3内已经弃用 dict1.items() #以列表返回可遍历的(键, 值) 元组数组 dict1.keys() #以列表返回一个字典所有的键 dict1.setdefault(key, default=None) #和get()类似, 但如果键不存在于字典中，将会添加此键、值(默认default)对到字典中哟 dict1.update(dict2) #把字典dict2的键/值对更新到dict1里（dict1内若有和dict2同名的键则dict2会覆盖dict1，若没有则添加到dict1中） # 声明两个字典 dict1 = {'a': 'luck', 'b': 'rose', 'c': '没有找到'} dict2 = {'a':'jack','d':'melon'} # 使用update方法 dict1.update(dict2) # {'a': 'jack', 'b': 'rose', 'c': '没有找到', 'd': 'melon'} dict1.values() #以列表返回字典中的所有值 集合 无序不重复的序列，可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典 a、函数 len(set1) 查看集合的长度 b、方法 set1.add(obj) 将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作 set1.update(obj) 添加一个元素到集合，参数可以是列表，元组，字典 set1.discard(obj) 移除集合中的元素，且如果元素不存在，不会发生错误 set1.pop() 从头部(下标为零)删除集合中的一个元素 set1.clear() 清空集合 5、数据类型转换 int()：转换为整型 str()：转换为字符串 float()：转换为浮点型 tuple()：转换为元组 list()：转换为列表 eval()：计算字符串中的有效Python表达式，并返回一个对象 6、运算符 算数运算符 + - / % //整除 *指数 赋值运算符 = 复合赋值运算符 += -= = /= //= %= *= 比较运算符 > = 逻辑运算符 and or not 7、共公操作符及内建函数 共公操作符 加号 + 合并 字符串、列表、元组 星号 * 复制 字符串、列表、元组；字典和集合不能和重复哟 in 元素是否存在，字符串、元组、列表、字典 not in 元素是否不存在，字符串、元组、列表、字典 内建函数 len(str) 计算容器中元素的个数，可用于字符串、列表、元组、字典、集合 str1 = 'hello world' print(len(str1)) # 11 id(valName) 当前变量名的内存地址，可以用于字符串、列表、元组、字典、集合 type(valName) 当前变量名的数据类型 del(valName) 删除当前变量 min(valName) 获取当前容器内的最小值，可以用于字符串、列表、元组、字典、集合 max(valName) 获取当前容器内的最大值，可以用于字符串、列表、元组、字典、集合 range(start, end, step) 生成从start到end的数字，步长为step，供for循环来使用 enumerate(可遍历对象， start=0) list1 = ['a', 'b', 'c'] for i in enumerate(list1, start=1): print(i) # 是一个元组哟(1, 'a') (2, 'b') ...... isinstance(要检测的类型变量，类型关键字) 比较变量是否是某个类型 locals() 在函数内使用locals()进行查看，可以看到当前函数内声明的内容有哪些哟 返回的是一个字典 globals() 查看全局变量有哪些，以字典的形式输出（注意里面会有一些系统键值对） 8、不可变类型 Python中，值都是靠引用来传递的（引用指的是变量名） 数据不能够直接进行修改，修改的不是其本身哟（新开辟了一个新的内存地址） 字符串、整形、浮点型、元组 字符串，当其值发生变化时就会再次的开辟一个新的内存空间 9、可变类型 Python中，值都是靠引用来传递的（引用指的是变量名） 数据能够直接的进行修改，修改的是其本身（使用的是同一个内存地址） 列表、字典、集合 10、推导式 只针对于列表、字典、集合，其目的是为了简化代码 列表格式1：[表达式 for 变量 in 列表 if 条件] 列表格式2：[结果1 if 条件 else 结果2 for 变量 in 列表 ] 字典格式：{key: value for k, v in 字典.items() if 条件 表达式} 集合格式：(表达式 for 变量 in 列表) 列表推导式：创建有规律的列表 list1 = [i+2 for i in range(10)] list2 = [i**2 for i in range(10) if i%2 == 0] print(list1) print(list2) 字典推导式 使用场景：快速合并列表或提取出字典中的目标数据 dict1 = {i, i**2 for i in range(1, 5)} print(dict1) # {1: 1, 2: 4, 3: 9, 4: 16} # 快速合并列表 list1 = [\"name\", \"age\", \"sex\"] list2 = [\"jack\", 18, \"男\"] dict3 = {list1[i], list2[i] for i in range(len(list1))} print(dict3) # {\"name\": \"jack\", \"age\": 18, \"sex\": \"男\"} # 提取字典中的目标数据 # 需求：提取数量大于200的字典数据 counts = {\"jack\": 89, \"rose\": 234, \"melon\": 198, \"luck\": 210} count1 = {key: value for key, value in counts.items() if value > 200} print(count1) # {\"rose\": 234, \"luck\": 210} 集合推导式 创建有规则的集合数据，使用频率不太高哟 list1 = [1, 1, 2] set1 = (i ** 2 for i in list2) # 集合内是可以自动去重的哟 print(set1) # (1, 4) 11、生成器 为什么要使用生成器？ 通过列表生成式（推导式），我们可以直接创建一个列表，但是受到内存的限制，列表容量肯定是有限制的，而且创建一个100万个元素的列表会占用很大的存储空间。如果我们仅仅需要前访问前面几个元素，那后面绝大多数元素占用的空间就白白的浪费了。那么列表可以按照某种算法推算出来，那我们是否可以循环的过程中不断的推算出后续的元素呢？这样就不必要创建完整的一个列表，从而节省了大量的内存空间。在Python中这种一边循环一边推算的机制，称为生成器（generator） 通过推导式定义生成器 把推导式中的花/方括号换成小括号 # 通过推导式获取生成器 g = (x*3 for i in range(10)) # g这是一个生成器对象 # 获取生成器内元素，方式一：使用生成器自身的__next__方法 print(g.__next__()) # 0 print(g.__next__()) # 3 # 获取生成器内元素，方式二：使用系统内置的next()方法 print(next(g)) # 6 print(next(g)) # 9 # 当生成器生成完后没有可生成的元素时会报出异常StopIternation(停止迭代) while True: try: e = next(g) print(e) except: print('没有元素可生成了') break 通过函数定义生成器 函数 + yield：只要函数中出现了yield关键字，则此函数就不是普通的函数了，就是一个生成器 定义一个函数且函数内使用yield关键字 调用此函数并接收结果（生成器） 借助于next() 获取元素 # 定义一个函数 def gener(): n = 0 while True: n = n + 1 yeild n # 此处的yeild相当于是 return + 暂停 暂停到此时，当下一个next()来时接着开始执行 n = n + 2 # yeild之后还是可以执行一些逻辑哟 g = gener() # 生成器 print(next(g)) # 1 print(next(g)) # 2 12、迭代器 可以通过next()方法调用的就叫迭代器 可迭代的 ：通过isinstance(要判断的对象, Iterable)的返回值(bool)来判断一个变量是否是可迭代的 注：可迭代的并不一定是迭代器（如列表、字典、集合、元组），迭代器一定是可迭代的 # 通过Interable()函数来判断一个变量是否是可以迭代的哟 from collection import Iterable list1 = [1,34,3,5,4,5,4,2] print(isinstance(list1, Iterable)) # True Int1 = 10 print(isinstance(Int1, Iterable)) # False 迭代器分类： 生成器是一个类别 通过Iter(变量)来转换的是一个类别 如：列表、集合、字典、元组、字符串都可以通过Iter()来转化为迭代器 # 通过系统的Iter()方法来转换为迭代器 list1 = [1,2,4,3,4,35,4,5] list1 = Iter(list1) string1 = 'jack' string1 = Iter(string1) print(next(string1)) # 其它类型等等。。。。。 二、开发环境 1、交互模式 可以直接书写Python代码哟，一般不会用于开发 三、流程控制 1、条件 if 条件一: # 要执行的语句一 elif 条件二: # 要执行的语句二 else: # 要执行的语句三 # 这是一个示例哟 if 'a' in 'melon': print('在melon内哟') # 这是三元运算符哟 print('是的') if 0 2、循环 四、函数 1、声明 def funName (param1, param1): print('this is function content') 注意：必须使用def来定义；必须要有缩进哟；必须要使用funName (): 格式 2、说明文档 在函数体的第一行默认为函数的说明文档 使用\"\"\" 这是书写函数的文档 \"\"\" 也可以是多行的哟 def userInfo(): \"\"\" 这是写函数的使用说明文档 \"\"\" print('this is function body') def getName(): \"\"\" 也可以是多行的哟 \"\"\" print('this is function body') 3、参数 位置参数 占位的参数，要严格按照其位置进行传递参数 def userInfo(name, age): print(\"这里是函数体\") 关键字参数 通过“键=值”的形式加以指定，参数参数之前位置可以调整，但关键字参数必须要放在位置参数以后来使用 def userInfo(name, age, sex): print('this is function body') # 函数的调用 userInfo('jack', sex='男', age='12') 缺省参数（默认参数） 调用函数时可以不传默认参数，但默认参数必须要放到位置参数之后 def userInfo(name, age=12, sex='未知'): print('this is function body') # 函数的调用 userInfo('rose', 18) userInfo('rose', sex='18') 不定长参数（可变参数） 用于不确定调用时会传递多少个参数（不传递参数也是可以的）的场景 包裹位置参数：使用*号来标识可变参数 函数内接收到的args为一个元组，没有传递参数时接收到的是一个空的元组 这叫包裹关键字参数：使用**号来标识可变参数 函数内接收到的kwargs为一个字典，没有传递参数时接收到的是一个空的字典 def userInfo(*args): \"\"\"这叫包裹位置参数\"\"\" print('this is function body') print(args) # 函数的调用 userInfo('jack', 23, '男') userInfo('rose') def getName(**kwargs): \"\"\"这叫包裹关键字参数\"\"\" print('this is function body') print(kwargs) # 函数的调用 userInfo(name='jack', age=23, sex='男') userInfo() 拆包 对元组、字典进行折包 def getNumber(): \"\"\"返回的是一个元组哟\"\"\" return 100, 200 num1, num2 = getNumber() print(num1) # 100 print(num2) # 200 ## 字典的拆包 dict1 = {'name': 'jack', 'age': 12} a, b = dict1 print(a) # name print(b) # age 4、作用域 全局：函数体内外都能够生效 局部：当前函数体内部生效 若要在函数体内使用全局变量就要使用global关键字哟 若在函数内使用全局变量时就要使用global 函数内嵌套函数时第二层的函数要使用第一层函数变量时使用nonlocal关键字 globals() 查看全局的变量，locals()查看局部的变量 作用域的范围： 从 L > E > G > B 结束 L：local 本地，局部变量 E：encloseing 嵌套 G：Global 全局 B：built-in 内置的 5、多返回值 多返回值以逗号进行分隔 def userInfo(): name = 'jack' age = 12 return name, age 6、闭包 符合条件： 外部函数中定义了内部函数 外部函数是有返回值的 外部返回值是内部函数 内部函数使用了外部变量 def outFun(): name = 'jack' def inFun(): print('this in in function', name) return inFun 特点： 保存参数的状态（多次调用返回的内部函数其返回值都有各自的状态） 可以使用同级的作用域 读取其它元素的内部变量 延长作用域 使用场景： 闭包看似优化了变量，原来需要类对象来完成的工作闭包也可以完成 由于闭包引用了外部函数的局部变量，则外部函数的的局部变量没有及时的释放，消耗内存 其好处是使代码变得简洁，易于阅读 其是理解装饰器的基础 外部函数的局部变量是可以保存状态的（例如：计数器） 7、装饰器 特点： 必须要使用函数作为参数来进行传递（函数B接收函数A作为参数传递） 要和闭包的的特点 不改变原函数名的情况下可以进一步的加工 使用方式在被装饰的函数上面使用@装饰函数名 若被装饰的函数有多个参数时，可以在装饰器中使用可变参数args, *args 若多个装饰器同时装饰一个函数时执行顺序是先近后远 装饰器带参数时在原来两层的基础之上再添加一层（用来接收装饰器的参数，一共三层） def decorate(func): ```我是装饰器 inName = 100 print('这里外层的代码就会执行哟') def wrapper(args, **args): func(args, **args) print('这里进一步的加工') return wrapper 使用装饰器 @decorate def house(): print('我的简单的房子，需要装饰哟') house() 装饰器干了什么 将被装饰的函数（house为被装饰的函数）作为参数传给了装饰器decorate 执行装饰器函数体内容 把装饰器的返回值又赋给了被装饰的函数（house = wrapper） 使用类作为装饰器 若要使用类作为装饰器的话，那么这个类就要重写__call()__(self)方法，否则就不能使用此类作为装饰器 # 定义一个类 class Decorator(): def __init__(self, func): self.func = func # 重写了__call__方法，类的对象就能够被调用，直接使用对象加()来调用类,并打印__call__方法里面的内容 def __call__(self, *args, **kwargs): print('this is dog call') return self.func # 使用类作为装饰器对函数进行装饰 @Decorator def dog(): return 'this is dog function' if __name__ == '__main__': dog() # this is dog call 为类添加装饰器 # 定义一个类的装饰器 def decorator(cls): print('this is a class 装饰器') return cls # 对类使用装饰器 @decorator class Dog(): name = 'jack' if __name__ == '__main__': d = Dog() # this is a class 装饰器 8、匿名函数 目的：为了简化代码 使用场景：一般用在系统内置函数中作为参数来使用 格式：lambda 参数1,参数2..... : 不需要return的函数体 #这是一个匿名函数的示例哟 l = lambda a, b : a + b print(l(1, 2)) # 3 list1 = [1,2,3,4,5,6] dict1 = {\"name\": 'jack', 'age': '12'} tuple1 = (2,5,7,8,9) list2 = map(lambda i: i**2, list1) print(list(list2)) dict2 = map(lambda v: (v, v), dict1) print(dict(dict2)) tuple2 = map(lambda i:i*2, tuple1) print(tuple(tuple2)) list3 = filter(lambda i: i>3, list1) print(list(list3)) dict3 = filter(lambda v: v == 'name', dict1) print(list(dict3)) tuple3 = filter(lambda i: i 五、文件操作 1、读文件 格式：open(文件, 模式, buffering, coding) 模式(mode) ​ 默认是“rt”文本模式 r: read 读取 w：write 写入 b：binary 二进制 rb：以二进制流方式读取 wb：以二进制流方式读取 方法： # 读取一个文件 # 返回一个管道，若没有此文件则会报FileNotFoundError，若文件读取模式不对则报UnicodeDecodeError stream = open('./test.txt') content = stream.read() # 从管道内读取内容 print(stream.readable()) # True 是否是可读取的 # 表示只读取一行内容(默认添加一个换行符)，前提是管道里面有内容时才可读，若已被读取则就获取不到内容 print(stream.readline()) print(stream.readlines()) # 表示读取所有行，返回一个列表 stream.close() # 关闭管道 # 高级使用 使用with as 可以自动的关闭文件管道(句柄) with open('./test.txt') as r_stream: content = r_stream.read() print(content) 2、写文件 open(文件， 'wb') 特点： write()：每次(open---close之间)都会把原来的内容清空，重新写入新的内容 模式： wb： 二进制写入模式 a：append追加模式，不会把原来的内容清空哟 # 向一个文件写入内容 stream = open(r'./test.txt', 'rb') content = '你好呀，我来写入点内容' result = stream.write(content) print(result) # 74 # writelines(可迭代的)，不会自动的换行哟，需要手动的换行 stream.writelines(['jack\\n', 'rose\\n', 'luck', 'melon']) print(stream.writeable) # True 是否是可写入的 stream.close() # 关闭管道 # 高级使用 使用with as 可以自动的关闭文件管道(句柄) with open('./test.txt') as w_stream: w_stream.write('hello Python') 3、OS模块 常用函数 import os # 获取指定文件的目录 os.path.dirname(__File__) # 拼接获取新的路径 os.path.join(文件/目录路径, 拼接1, 拼接2) # 分割目录与文件名，返回一个元组 （目录，文件名.扩展名） os.path.split(文件/目录路径) # 分割目录与文件扩展名，返回一个元组（目录，扩展名） os.path.splittext(文件路径) # 获取当前文件路径所指文件的大小 os.path.getsize(文件路径) # 判断当前路径是否是目录 bool os.path.isdir(目录路径) # 判断当前路径是否是文件 bool os.path.isfile(文件路径) # 判断当前路径是否是绝对路径 bool os.path.isabs(文件/目录路径) # 获取当前目录 path = os.path.getcwd() # 浏览文件夹，类似于ls 返回一个列表['aa.txt', 'bb.doc', 'cc'] file_list = os.path.listdir() # 创建一个新的文件夹 os.path.mkdir('doc') # 删除空的文件夹 os.path.rmdir('pp') # 删除一个文件 os.path.remove(文件路径) # 切换目录 os.path.chdir(目标路径) 六、异常 1、异常捕获 目的：处理可能要发生的异常错误 当我们认为某些代码可能会出错时，就可以用try来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即except语句块，执行完except后，如果有finally语句块，则执行finally语句块，至此，执行完毕。 注：使用try except 后，若有异常出现时就可以执行其后的逻辑了（正常情况下有异常就会终止程序） 特点： 只要使用finally则try/except/else 内的return的值就不会被返回，都会使用finall中的 具体的错误类型一定要放到Exception之前，否则具体的类型就会执行不到的哟（因为有继承关系） 若使用else的话则try内和else内则只能有一个地方使用return哟（建议在else内使用return） except Exception as err 其中的err为具体的错误内容 # 异常处理 try 不能单独使用，必须要和except配合使用哟 try: # 可能出现异常的代码 pass except 错误类型1: # 如果有异常执行的代码，可通过不同的类型来做不同的区分，except可以有多个哟 # 错误类型，如：ZeroDivisionError、ValueError等 pass except 错误类型2: # 如果有异常执行的代码，可通过不同的类型来做不同的区分，except可以有多个哟 # 错误类型，如：ZeroDivisionError、ValueError等 pass except Exception as err: ''' 1、继承关系：ValueException --> Exception --> BaseException --> Object 2、具体的错误类型一定要放到Exception之前，否则具体的类型就会执行不到的哟（因为有继承关系） 3、也可以自定义所需要的异常类（如：class MyError(Exception)） ''' print('错误内容为：{}'.format(err)) pass else: # 如果try中没有发生异常，将会执行else语句 # 若使用else的话则try内和else内则只能有一个地方使用return哟（建议在else内使用return） pass finally: # 无论是否有异常都会被执行的代码 # finally有一个特点：只要使用finally则try/except/else 内的return的值就不会被返回，都会使用finall中的 pass 2、抛出异常 关键字：raise 格式：raise Exception(异常的内容) 使用raise可以自定义的抛出异常，开发中不常使用，多数是在查看源码时辅助理解 def fun1(age): if age 七、类与对象 1、声明 关键字: class 类名： 首字母要大写 # 声明类 class 类名[(父类)]: class Phone: brand = 'xiao mi' # 类属性 def getBrand(self): print('this is body' , self) 2、生成对象 在类名后添加小括号，就是使用类生成对象 每一个对象都会新开辟一个新的内存空间 iPhone = Phone() iPhone.brand = 'hua wei' # 对象属性 print(iPhone) 3、属性 对象中属性的查的顺序：先从本对象内查找，若没有找到，则到其类里面进行查找，若都没有找到则会报出AttributeError 对象内的属性是可以动态添加的，使用赋值操作来添加对象属性 iPhone.brand = 'hua wei' 4、方法 分类：普通方法、类方法、静态方法、魔术方法 格式：def 方法名(self[,参数1, 参数2....]): # 类的声明 class Phone: name = 'hua wei' weight = 12 # 此为魔术方法, 类似于构造方法 # 此方法会在为对象分配好内存后执行同时把对象地址给self,之后把地址再赋值给对象变量名 # 此方法作用可统一对象的属性，规定规则，在开发中很常用哟 def __init__(self, age): self.age = age print(self) # 此为普通方法 def call(self): # self代表的是当前调用此方法的对象 print(self.name) # 此为类方法，要使用装饰器来指定 @classmethod def classFun(cls): print(cls) # 是指的当前的类Phone 普通方法 普通方法(对象可使用的方法)，其使用只能是对象可调用的，其参数self指的是当前调用的那个对象本身 可以在普通方法中使用类属性、类方法 # 类的声明 class Phone: name = 'hua wei' weight = 12 def call(self): # self代表的是当前调用此方法的对象 print(self.name) # 使用类生成对象 phone1 = Phone() phone1.name = 'xiao mi' phone1.call() 类方法 类方法在没有生成对象时可以直接进行调用，其在类声明时就已经加载好了 特点： 定义类方法需要依赖装饰器@classmethod 类方法中参数不是一个对象，而是一个类 类方法中只可以使用类属性、类方法，不可以访问普通方法 作用： 在对象创建之前，如果需要完成一些动作就可以使用类方法 class Phone: # 使用装饰器classmethod @classmethod def getName(cls): ```其中的cls参数为必填参数，不可以省去 print(cls) # cls是当前类本身 类方法的调用，使用类直接进行调用 p1 = Phone.getName() 类方法也可以使用对象对其调用 p2 = Phone() p2.getName() ### 静态方法 和类方法一样，在类声明时就已经加载好了 **特点：** - 需要装饰器@staticmethod - 静态方法是无需传递参数的（cls 、self） - 只能访问类属性和类方法，不能访问对象属性和对象方法 **静态方法对比类方法：** - 相同： - 只能访问类属性和类方法，对象的是不能访问的 - 都可以通过类名及对象名来进行调用 - 都可以在创建对象之前调用（因为不依赖于对象） - 不同： - 装饰器不同@classmethod @staticmethod - 类方法有参数，静态方法没有参数 **普通方法VS静态、类方法** - 不同： - 普通方法没有装饰器，后两者是有装饰器 - 普通方法永远是依赖于对象的（有self参数），后两者是不依赖于对象 - 只能创建了对象，使用对象才能调用普通方法，后两者可以使用类名直接调用 - 相同： - 都可以使用对象来进行调用 ```python class Phone: # 使用装饰器staticmethod @staticmethod def getName(): pass # 其不需要有cls或self参数 # 静态方法的调用，使用类直接进行调用 p1 = Phone.getName() # 静态方法也可以使用对象对其调用 p2 = Phone() p2.getName() 魔术方法 系统定义的，在特定条件下可以被自动的调用 __new__(cls)在实例化时触发（申请内存空间），至少一个cls参数，必须返回一个对象实例，先实例化(new)后初始化(init) __init__(self) 构造器，在初始化对象时触发（等到内存空间后第一个被调用），至少有一个self参数，没有返回值，使用该方式初始化的成员都是直接写入对象中，类中无法具有 __del__(self)析构器，当一个实例被销毁的时候调用的方法，也就是说在断开对其的引用时或已经没有被引用时 __call__(self) 允许一个类的实例像函数一样被调用：x(a, b) 调用 x.__call__(a, b) __getattr__(self, name) 定义当用户试图获取一个不存在的属性时的行为 ___setattr__(self, name, value) 定义当一个属性被设置时的行为 __getattribute__(self, name) 定义当该类的属性被访问时的行为 __delattr__(self, name) 定义当一个属性被删除时的行为 __enter__(self) 定义当使用 with 语句时的初始化行为 __exit__(self, exc_type, exc_value, traceback) 定义当一个代码块被执行或者终止后上下文管理器应该做什么 class Phone: # 可以看成是构造方法，对象中的属性可以在此进行定义 # 当对象被生成后被调用 def ___init___(self): print(self.name) # 必须有self参数， self为当前调用的对象本身 # 打印对象时自动的调用此函数 def ___str___(self): print(self.name) # 生成对象并为对象开辟内存空间时自动调用，一般不常用 def ___new___(cls): #cls为必传参数，表示类本身 print(cls) # 把对象当作时一个函数来调用时会自动被调用 def ___call___(self): print(self) # 当对象没有被引用时(销毁时)被自动调用 def ___del___(self): print(self) 5、私有化 将类的属性私有化，访问范围仅仅限于类中； 好处： 隐藏属性不被外界随意的修改 也可以修改，通过set/get进行修改获取值 class Phone: def ___init___(self, name): self.__name = name def setName(self, name): # 在这里可以做条件的限制哟 self.__name = name return self.__name def getName(self): return self.__name p = Phone('rose') p.setName('jack') p.getName() @property 装饰器私有化， 来替换使用get/set的方式来操作私有属性 ```python class Phone: def ___init___(self): self.__name = 'xiao mi' # 使用property装饰器来实现getName获取私有属性 @property def name(self): return self.__name # 使用XXX.setter来实现设置私有属性 @name.setter def name(self, name): return self.__name = name 调用 p = Phone() p.name = 'hua wei' print(p.name) # hua wei ## 6、关联关系 - **A** is a **B** 说明B是A的父级 如：A是B的父级 - **A** has a **B** 说明A包含了B 如：B是A的属性 ## 7、继承 继承是一种创建新的类的方式，新创建的叫子类，继承的叫父类、超类、基类。 **特点**： - 子类可以使用父类的属性（特征、技能），可以单继承，也可以多继承(不常用) - 继承是类与类之间的关系 - **子类对象查找属性及方法的顺序是**：先从本身查找、之后向上级一层一层的查找，若没有找到则报错 - 子类中使用父类中的方法时使用**关键字super** **目的**：减少代码冗余、提高重用性 所有的类都会继承Object类 格式：class 类名(父类名): ```python class Person: def __init__(self, name): self.name = name def eat(self, food): print(f'小海在吃{food}') # 子类继承父类 class Tom(Person): def __init__(self, name): super().__init__(name) self.name = name # 子类重写父类的方法 def eat(self, food): super().eat(food) print(f'{self.name}和小海吃{food}了') # 调用 t = Tom('tom') t.eat('屎') 多继承： ​ 如： class D(A, B, C): ​ 特点：广度优先 ​ 其查找顺序是 D > A > B > C > Object 8、模块 模块就是一个包含了python定义和声明的文件，文件名就是模块的名字加上.py后缀 格式： ​ import 包名[.模块名 [as 别名]] ​ from 包名 import 模块名 [as 别名] ​ from 包名.模块名 import 成员名 [as 别名] 目的 ​ 代码可以重用，把相关的功能进行分离,以便我们的日常维护,以及新项目的开发 导入模块的时候都做了些什么? ​ 首先,在导入模块的一瞬间,python解释器会先通过sys.modules来判断该模块是否已经导入了该模块,如果已经导 入了则不再导入,如果该模块还未导入过,则系统会做三件事. - 为导入的模块创立新的名称空间 - 在新创建的名称空间中运行该模块中的代码 - 创建模块的名字,并使用该名称作为该模块在当前模块中引用的名字. 八、数据库 操作数据库的两种方式： 原生SQL pymysql： python2/python3 都可以使用，一般要配合DBUtils来使用 MySQLdb：只支持python2 ORM SQLachemy（其内部原理还是调用pymysql/MySQLdb） 其功能是把模型对象和表的字段对应，操作时生成对应的SQL语句，其它工作交由Pymysql处理 其可以生成、删除表（不能修改表结构）或操作CURD 1、mysql 数据库：数据的仓库(集散地)，实现数据持久化和数据管理 持久化：将数据从内存转移到能够长久保存数据的存储介质的过程 完整性： 实体完整性 - 每一个实体都是独一无二的，没有冗余（主键、唯一索引） 参照完整性 - 外键 域的完整性 - 存储的数据都是有效的（数据类型、长度、非空约束、默认值） 一致性：事务，要么全成功要么全失败，操作是不可分割的（ACID特性） A - Atomicity - 原子性 - 不可分割 C - Consistency - 一致性 - 事务前后数据状态要一致 I - Isolation - 隔离性 - 并发的多个事务不知道彼此的中间状态 D - Duration - 持久性 - 事务完成后数据要做持久化 2、pymysql 安装： pip install pymysql 使用： # 1、创建链接对象 conn = pymysql.connect(host=\"127.0.0.1\", port=3306, user=\"root\", password='123456', database='rooms', charset='utf8') try: # 2、获得游标对象 with conn.cursor() as cursor: # 3、使用游标进行操作SQL得到结果 result = cursor.execute('insert into rooms (29,\"\", \"\")') if result == 1: print('添加成功') # 4、操作成功后进行提交(因为不会自动进行提交) conn.commit() # 这里是查询操作 with conn.cursor() as cursor: # 3、使用游标进行操作SQL得到结果 cursor.execute('select * from rooms') for row in cursor.fatchall: # 这里的row是一个二级的无组哟, 如：(('jack', 23), ('rose', 12), ('melon', 12)) print(f'字段一：{row[0]}') # 这里可以和下面的room对象进行绑定哟(得把cursorclass设置为DistCursor) room(**row) except pymysql.MySQLError as error: print(error) # 5、若异常进行回滚 conn.rollback() finally: # 6、最终关闭链接，释放资源 conn.close() 和对象进行关联： class room(): def __init_(self, name, age): self.name = name self.age = age def __str__(): print(f\"{self.name}\\t{self.age}\") 使用原生的SQL可能会出现那些问题？ 每一个人来就会创建一个数据库链接（数据库的可链接数有限的哟） 如果把链接放到全局会如何呢 - 多个人并发时第一个人已经查出来信息并关闭链接了，同时第二个人刚查出来数据，此时就会报错哟 问题一：不能为每一个用户都去创建一个链接 问题二：创建一定数量的链接，以便来重复使用（用完就还回去不进行断开链接） 方案一：可以放到全局的同时使用threading.Lock()加锁限制，这样是可以的，但不能实现并发操作，数据库只能一个一个来处理 方案二：使用DBUtils模块，可参考 链接 # 下载DBUtils模块，到其setup.py所在目录下 # 执行命令一：python setup.py build # 执行命令二：python setup.py install # 使用DBUtils 有两种链接模式 可参考https://www.cnblogs.com/wupeiqi/articles/8184686.html,推荐使用第二种模式（惰性创建） 3、SQLAlchemy 是一个基于Python实现的ORM框架。该框架建立在 DB API之上，使用关系对象映射进行数据库操作，简言之便是：将类和对象转换成SQL，然后使用数据API执行SQL并获取执行结果。 字段类型 Integer -- int 整型数字类型，普通整数，一般是32位 SmallInteger -- int 取值范围小的整数，一般是16位 BigInteger -- int/long 不限制精度的整数 Float -- float 浮点数 Numeric -- decimal.Decimal 普通整数，一般是32位 String -- 变长字符串，一般String(10)注明长度 Text -- 变长字符串，对较长或不限长度的字符串做了优化，不用指明长度 Unicode -- 变长Unicode字符串 UnicodeText -- 变长Unicode字符串，对较长或不限长度的字符串做了优化 Date -- datetime.date 时间 DateTime -- 时间和日期 Boolean -- boolean 布尔值 列选项 primary_key -- 主键，True、False unique -- 如果为True，代表这列不允许出现重复的值 index -- 如果为True，为这列创建索引，提高查询效率 nullable -- 如果为True，允许有空值，如果为False，不允许有空值 default -- 定义默认值 可参考： 链接 九、Redis Redis： REmote DIctionary Server（远程字典式服务） 下载地址 链接 文档地址 链接 1、应用场景 主要应用对象是“热数据”，冷数据（不经常使用的）/ 热数据（经常使用的） 高速缓存服务（用户经常访问的数据从数据库搬到内存） 实时排行榜 投票点赞 消息队列 2、常用命令 port -- 端口号 version -- 查看版本号 requirepass -- 设置密码 appenonly -- 记录命令日志 # 在命令行进行执行 # 启动服务的命令 redis-server --port 6379 --requirepass 1qaz2wsx redis-server /data/www/redis/redis.conf & redis-server > redis.log & # 查看后台启动的服务 jobs -l # 查看服务列表 fg %[number] # 把服务放到前台 bg %[number] # 把服务放到后台 # 启动Redis客户端的命令 redis-cli -h 主机IP地址 -p 端口号 主机:端口> auth 密码 主机:端口> ping PONG # 停止Redis服务 # 在Redis客户端中执行shutdown 后就可以停止Redis服务 kill 进程号 # 测试Redis的性能 redis-benchmark # 查看版本号 redis-server --version redis-cle --version # 查看当前有没有启动Redis netstat -nap | grep redis 十、Session 使用场景：用户登录、登出、验证用户、城市定位 十一、Cookie Cookie数据存储技术，它的数据存储在客户端（浏览器），在浏览器中会为每个站点（host）创建存储Cookie的空间出来，Cookie的数据存储以Key=Value形式进行存储的，但是每个Key都有生命周期（有效期）。一个完整的Cookie信息包含：名称、内容、域名、路径(/)、有效时间（创建时间、到期时间） 特点： cookie有有效期：服务器可以设置cookie的有效期，以后浏览器会自动的清除过期的cookie。 cookie有域名的概念：只有访问同一个域名，才会把之前相同域名返回的cookie携带给服务器。也就是说，访问谷歌的时候，不会把百度的cookie发送给谷歌。 1、 向客户端写入Cookie 格式： def set_cookie( self, key, # 要设置的Key value=\"\", # 对应的Value值 max_age=None, # 以秒为单位，距离现在多少秒后cookie会过期，若expires同时存在则以expires为准 expires=None, # 为datetime类型。这个时间需要设置为格林尼治时间，也就是要距离北京少8个小时的时间，如果没有显示的指定过期时间，那么这个cookie将会在浏览器关闭后过期 path=\"/\", domain=None, # 默认是只能在主域名下使用。如果想要在子域名下使用，那么应该给`set_cookie`传递一个`domain='.demo.com'`，这样其他子域名才能访问到这个cookie信息。 secure=False, httponly=False, samesite=None, ):pass # 需要使用响应对象来调用set_cookie 或 delete_cookie方法 2、获取Cookie # 客户端的cookie信息随着请求发送，自动将浏览器中的Cookie附加到请求头中 # 可以在请求对象中获取浏览器的Cookie值信息 from false import request co = request.cookies.get('yes') # 获取Cookie值 3、删除Cookie def delete_cookie( self, key, path=\"/\", domain=None ):pass 十二、包管理器 作用：Python库是指那些被开发并且为了其他人来使用而发布的东西，可以在 PyPI找到很多Python库，目的是为了解决\"不重复的造轮子\" 发展：按时间(由新到旧)：pip --> setuptools(easy_install) --> distutils distutils：最古老的方式，通过setup.py来安装与发布 python setup.py install setuptools：是一个为了增强 distutils 而开发的集合，它包含了 easy_install 这个工具 pip：是目前 python 包管理的事实标准，它被用作 easy_install 的替代品，但是它仍有大量的功能建立在setuptools 组件之上 相关文件 setup.py Python库会包含很多的信息，比如它的名字，版本号，依赖等等。而 setup.py 就是用来提供这些信息的 可以理解为是\"抽象的依赖\" from setuptools import setup setup( name=\"MyLibrary\", version=\"1.0\", install_requires=[ \"requests\", \"bcrypt\", ], # ... ) requirements.txt 一般一个Python库对依赖的版本比较宽松，而一个应用则会依赖比较具体的版本号 可以理解为是\"具体的依赖\" # This is an implicit value, here for clarity --index https://pypi.python.org/simple/ MyPackage==1.0 requests==1.2.0 bcrypt==1.0.2 文件的头部有一个 --index https://pypi.python.org/simple/ ，一般你不用声明这项，除非你使用的不是PyPI 常用命令 使用pip(包管理器) 来管理应用的依赖包 # 使用帮助 pip --help # 从PyPI安装软件包 pip install SomePackage # 卸载软件包 pip uninstall SomePackage # 查看以安装软件包 pip list # 查看可升级软件包 pip list --outdated # 升级软件包 pip install --upgrade SomePackage # 查看软件包安装了哪些文件及路径等信息 pip show --files SomePackage # 安装软件包的指定版本号 pip install SomePackage # latest version pip install SomePackage==1.0.4 # specific version pip install 'SomePackage>=1.0.4' # minimum version # 根据依赖文件安装软件包 pip freeze > requirements.txt # 使用pip导出依赖文件列表 pip install -r requirements.txt # 根据依赖文件列表，自动安装对应的软件包 © 2021 易多客 京ICP备17028238号-1 all right reserved，powered by Gitbookmodify at： 2021-02-26 09:39:34 "},"tech/React基础知识.html":{"url":"tech/React基础知识.html","title":"React基础知识","keywords":"","body":"一、关于React React不是一个完整的MVC框架，最多可以认为是MVC中的V（view），甚至React并不非常认可MVC开发模式，React是构建页面UI的库，可以认为React将页面分成了各个独立的小块，第一个块就是一个组件，这些组件之间可以组合、嵌套，就成了页面。 特点： 虚拟DOM 其定义了一套变量形式的Dom模型，一切操作和换算直接在变量中操作，减少操作真实的dom 组件系统 将页面中的任何一个区域或者元素都可以看做一个组件Component（html,css,js,image元素的聚合体） 单向的数据流 JSX语法 1、安装 // 全局安装 create-react-app npm install -g create-react-app // 创建一个项目 create-react-app your-app /* 等待一段时间，这个过程会安装三个东西 1、react: react的顶级库 2、react-dom: react有很多的运行环境，如：app端的react-native; web端的使用react-dom 3、react-script: 包含运行和打包react应用程序的所有脚本及配置 安装成功后： npm start npm run build npm test npm run eject */ 二、元素与组件 react中元素和组件的区别 元素：是小写格式的 dev 组件：是大写的驼峰命名ClassCom 1、元素 是React组成应用最小的单元，和Html标签一至，全小写。 2、组件 分为两种：函数式组件、类组件 函数式组件 以函数的方式定义组件，其返回一个JSX对象 // 定义函数式组件 function Childcom(props){ //这里还可以书写其它的逻辑 let title = 函数式组件 let isShow = true ? 这是一个显示的文本 : '' let myName = props.myName return ( /*这里必须有且只有一个根元素*/ {title} this is my name : {myName} {/*这里进行注释的书写*/} hello jsx {isShow} ) } // 把组件渲染出来 ReactDOM.rander( document.querySelector('#root') ) 类组件 类组件是要继承React.Component类 Class Person extends React.Component{ // 使用render函数来进行渲染 render(){ // 这里同样返回一个JSX对象 return ( hello 类组件 ) } } 三、JSX原理 JSX 是一个看起来很像 XML 的 JavaScript 语法扩展，JSX 是在 JavaScript 内部实现的 JSX 就是用来声明 React 当中的元素 原理： 要明白JSX的原理，需要先明白如何用JavaScript对象来表现一个DOM元素的结构？ // 这是一个Html信息 ` go home ` // 其对应的javascript对象如下（也就是虚拟DOM） { tag: 'div', attrs: {className: 'app', id: 'appRoot'}, childen: [ { tag: 'h1', attrs: {className: 'title'}, childen: ['go home'] } ] } // 但是用javascript写起来太长了，结构看起来又不清晰，用Html的方式写起来就比较方便。于是React.js就把Javascript的语法扩展了一下，让JavaScript语言能够支持这种直接在JavaScript代码里编写类似Html标签结构的语法，这样写起来就方便多了。编译的过程会把类似Html的JSX结构转换成JavaScript的对象结构。 let exampleStyle = {background: 'skyblue'} let className = ['one', 'tow'].join(\",\") // 这是一个jsx对象，可使用圆括号进行包括 let element = ( {/*这里进行注释的书写*/} hello jsx ) // 上面的elemment变量对应的JSX转换为虚拟DOM后的结构如下： React.createElement( 'div', // 标签名 null, // 标签属性 React.createElement( // 子组件 'h1', // 标签名 {className:'yes', style=\"color:red;\"}, // 属性 'hello jsx', // 内容 ) ) 四、组件中DOM样式 1、行内样式 想给虚拟DOM添加行内样式，需要使用表达式传入样式对象的方式来实现； // 这里有两个花括号，第一个表示我们要在jsx中插入js，第二个表示对象的括号 hello react // 行内样式需要要写入一个对象，这个对象可以写在很多的地方，比如：render函数内，组件原型上，外链js文件中 let myStyle = {color:'red', fontSize:'14px'} hello react 2、使用class React推荐我们使用行内样式，因为React觉得每一个组件都是一个独立的整体，注：class需要写成className（毕竟是在写类js，而class是一个关键字） hello react 3、不同条件下添加不同样式 有时候需要根据不同的条件添加不同的样式，推荐使用classnames这个包 4、css-in-js 其是针对React写的一套css-in-js框架（在js中写样式），styled-components包 // 定义 import styled from 'styled-components' const DivContainer = styled.div` font-size: 100px; color: greenyellow; ` export { DivContainer } // 使用,当作是组件来进行使用 this si styled-components 五、组件的数据挂载方式 1、属性(props) props正常是外部传入的，组件内部也可以通过一些方式来做初始化的设置，属性不能被组件自己更改，但是可以通过父组件主动重新渲染的方式来传入新的props，其是描述性质、特点的，组件自己不能随意的变更。 获取方式： 把参数放在标签的属性当中，所有的属性都会作为组件props对象的键值，通过箭头函数创建的组件，需要通过函数的参数来接收props; a、设置组件的默认props // 当为类组件时，有两种方式 // 第一种方式在类组件内：为props设置默认值 static defaultProps = { title: 'this si defaultProps' } // 第二种方式在类组件外：为props设置默认值 ClassCom.defaultProps = { title: 'this is out defaultProps' } // 当为函数组时 // 为props设置默认值 FunctionCom.defaultProps = { title: 'this is out defaultProps' } b、props.children 组件是可以嵌套的，若在使用自定义的组件时需要获取子组件时就需要使用props.children // this.props.children为本组件内的内容，有点类似于vue中的插槽 c、使用prop-style检查props vue中有检查及预定props的语法，react中也可以使用props-types来检查props的参数类型 import PropTypes from 'prop-types' // 在类组件内对props进行类型的验证 static propTypes = { title: PropTypes.string } 2、状态（state） 是组件描述某种显示情况的数据，由组件自己设置和更改，也就是由组件自己进行维护，使用状态的目的就是在不同的状态下使组件显示不同(自己管理) class ClassCom extends Component { // 定义组件state的第一种方式，在构造函数内定义(推荐) constructor(props) { super(props) this.state = { name: 'jack', age: 18 } } // 定义组件的第二种方式，直接进行定义 /*state = { name = 'jack', age = 23 }*/ // 添加一个事件 handleBtnClick = () => { this.setState({ name: 'rose' }) } render() { return ( hello this is my name: {this.state.name} ) } } this.props和this.state是纯js对象，在vue中data属性是利用object.defineProperty处理过的，更改data的数据时会触发数据的getter和setter方法；React中没有做这样的处理，若直接进行修改的话，React是无法得知的，所以要使用特殊的更改状态的方法setState setState有两个参数，第一个参数可以是一个对象，也可以是方法return一个对象，我们把这个参数叫做updater 参数是一个对象 this.setState({ name: 'melon' }) 参数是方法 // 方法的第一个参数是上一次的state，第二个参数是props this.setState((prevState, props) => { return { name: prevState + ' rose' } }) 第二个参数 setState是异步的，所以要想获取到最新的state，是没有办法获取的，于是就有了第二个参数（回调函数，当state更新成功后会回调此函数） this.setState({ name: 'melon' }, () => { console.log('state 更新成功后的回调', this.state.name) }) 3、属性VS状态 相同点：都是纯js对象，都会触发render更新 不同点： 属性能从父元素获取，状态不能 属性可以由父组件修改，状态不能 属性可以在组件内部设置默认值，状态也可以 属性不能在组件内部修改，状态可以 属性可以设置/修改子组件的值，状态不可以 state的主要作用是用于组件保存、控制、修改自己的可变状态。其在组件内部进行初始化，可以被组件自身修改，而外部不能访问也不能修改，其值可以通过setState方法来更新，setState方法会员导致组件的重新渲染。 props的主要作用是让使用该组件的父组件可以传入参数来配置该组件。外部传入的值组件内部是无法控制也无法修改（除非外部组件主动的传入新的props否则组件的props永远保持不变） 提示： 尽量少使用state，多使用props。尽量多写无状态的组件，少写有状态的组件。 4、状态提升 如果有多个组件共享一个数据，把这个数据放到共同的父级组件中来管理 // 父组件内 state = { data: '' } child1Click = (data) => { tihs.setState({ data }) } // 通过第一个子组件内接收到父组件的函数，触发后来改变第二个子组件内的显示数据 5、受控组件与非受控组件 组件的数据渲染是否被调用者传递的props完全控制，控制内里为受控组件，否则为非受控组件。 // 一个组件内 constructo(props) { super(props) this.ipt = createRef() // 从React中导入 import createRef from 'React' } handleChange = () => { this.setState({ data: 'yes' }) } render() { return () { {/*这个input 是一个受控组件*/} {/*这个input 是一个非受控组件 使用createRef*/} } } 6、渲染数据 条件渲染 // state中 state = { name: condition ? 'jack' : 'rose' } 列表渲染 render() { return () { lists.map(item => { return ( {/*key 就是每一个元素的标识*/} {item.name} ) }) } } dangerouslySetInnerHTML 第三方来的数据都是不可信的，使用dangerouslySetInnerHTML可以使用html代码生效 六、事件处理 1、绑定事件 React中的事件采用“on+事件名” 的方式来绑定一个事件，要注意和原生事件的区别，原生事件全是小写如：onclick；React事件是驼峰写法onClick； React的事件并不是原生事件，而是合成事件。 2、事件handler的写法 在组件内使用箭头函数定义一个方法（推荐） 直接在组件内容定义一个非箭头函数的方法，然后在constructor里bind(this) （推荐） 直接在render里写行内的箭头函数(不推荐) 直接在组件内定义一个非箭头函数的方法，然后在render里直接使用onClick={tihs.handleClick.bind(this)} （不推荐） class clickHandle extends React.Component{ constructor(props){ super(props) // 直接在组件内容定义一个非箭头函数的方法，然后在constructor里bind(this) （推荐） this.myClick001 = this.myClick001.bind(this) } // 在组件内使用箭头函数定义一个方法（推荐） 同时也支持参数的传递 myClick = (params) => { return () => { console.log(params) } } myClick001(event) { console.log('my-click-001') console.log(event.target) } myClick002() { console.log('my-click-002') } render() { return () { } } } 3、Event对象 和普通浏览器一样，事件handler会被自动传入一个envent对象，这个对象和普通和浏览器envent对象所包含的方法和属性都基本一致，不同的是React中的envent对象不是浏览器提供的，而是它自己内部所构建的，它同样具有和浏览器一样的常用方法 七、表单 八、Hooks © 2021 易多客 京ICP备17028238号-1 all right reserved，powered by Gitbookmodify at： 2021-10-21 15:53:58 "},"tech/Vim基础知识.html":{"url":"tech/Vim基础知识.html","title":"Vim基础知识","keywords":"","body":"一、常用命令 变量的作用域global/local/static global是全局变量，local是函数内局部变量，static是函数内局部变量 全局变量要是局部使用需要用global关键字 局部变量不能在全局使用 echo , print 和 print_r的区别: echo - 可以输出一个或多个字符串，没有返回值 print - 只能输出一个简单类型变量的值,如int,string，返回值为1 print_r - 可以输出一个复杂类型变量的值,如数组,对象 二、命令全称 r/R replace 替换 i/I insert 插入 a/A append 追加 u/U undo 撤回；ctrl + r redo 重新执行 ^/$ ^加到行首；$回到行尾 b/B before 向前；b为小步；B为大步； e/E end 向后；e为小步；E为大步； r/R replace 替换；r为替换一个字母；R为不断的进行替换； f find 发现；命令:f查看当前行的状态 d/D delete 删除；dd删除一行且光标定位到第二行--命令行模式；D删除当前位置到本行尾且光标定位在当前不动--命令行模式； c/C change 改变；cc为删除当前行且光标在当前行首--插入模式；C和cc作用一样； v/V visual 视觉的；v普通选择模式；ctrl + v 为块选择方式；V为行选择方式； y yank 猛拉；yank === copy p/P paste 粘贴；p粘贴到当前光标后面；P粘贴到当前光标前面； o/O open 打开一行；o为open above在上一行添加一行；O为open below在下一行添加一行； 运算符 名称 描述 实例 x and y 与 如果 x 和 y 都为 true，则返回 true x=6 y=3 (x 1) 返回 true x or y 或 如果 x 和 y 至少有一个为 true，则返回 true x=6 y=3 (x==6 or y==5) 返回 true x xor y 异或 如果 x 和 y 有且仅有一个为 true，则返回 true x=6 y=3 (x==6 xor y==3) 返回 false © 2021 易多客 京ICP备17028238号-1 all right reserved，powered by Gitbookmodify at： 2021-05-07 18:45:30 "}}